{"config": {"glob_patterns": ["docs/**/*.md"], "hooks": ["markata.plugins.publish_source", "markata.plugins.docs", "default"], "disabled_hooks": ["markata.plugins.manifest", "markata.plugins.rss"], "markdown_extensions": [], "default_cache_expire": 1209600, "output_dir": "markout", "assets_dir": "static", "site_version": 13, "url": "https://markata.dev", "title": "Markata's Docs", "description": "Documentation for using the Markata static site generator", "rss_description": "Markata docs", "author_name": "Waylon Walker", "author_email": "waylon@waylonwalaker.com", "icon": "favicon.ico", "lang": "en", "theme_color": "#322D39", "background_color": "#B73CF6", "start_url": "/", "site_name": "Markata", "short_name": "ww", "display": "minimal-ui", "twitter_card": "summary_large_image", "twitter_creator": "@_waylonwalker", "twitter_site": "@_waylonwalker", "feeds": {"autodoc": {"title": "All Markata Modules", "filter": "True", "card_template": "<li class='post'><a href='/{{ slug }}/'>{{ slug }}</a></li>"}, "core_modules": {"title": "Markata Core Modules", "filter": "'plugin' not in slug", "card_template": "<li class='post'><a href='/{{ slug }}/'>{{ slug }}</a></li>"}, "plugins": {"title": "Markata Plugins", "filter": "'plugin' in slug", "card_template": "<li class='post'><a href='/{{ slug }}/'>{{ slug }}</a></li>"}}}, "articles": [{"cover": "", "title": "Getting Started with Markata", "tags": [], "status": "draft", "templateKey": "", "path": "docs/index.md", "description": "Guide to get going with Markata", "content": "Markata is a fully plugins all the way down static site generator for\nfolks who just want their site to get started quickly and build great\ncontent, with the ability to tinker with everything under the hood if\nthey want to.\n\n## QuickStart\n\nMarkata is fully configurable through a `markata.toml` file, but the defaults\nallow to build your site right out of the box with nothing more than markdown.\n\n### Create Some Content\n\n```\nmkdir pages\necho '# My First Post' > first-post.md\necho '# Hello World' > hello-world.md\n```\n\n### Build your site\n\n``` bash\npip install markata\nmarkata build\n\n# or if pipx is your thing\npix run markata build\n```\n\n### Frontmatter\n\nYou will likely want to set things like `title`, `date`, `description`,\n`status`, or `template` per post, this can all be done inside yaml frontmatter.\n\n``` markdown\n---\ntemplateKey: blog-post\ntags: ['python',]\ntitle:  My Awesome Post\ndate: 2022-01-21T16:40:34\nstatus: draft\n\n---\n\nThis is my awesome post.\n\n```\n\n> Frontmatter is not required, but definitely gives you more control over your site.\n\n## Next steps\n\n* [create your home page](https://markata.dev/home-page/)\n\n## Source Code\n\nIf you have comments, questions, issues, or like it enough to give a \u2b50\ncheck out\n[waylonwalker/markata](https://github.com/WaylonWalker/markata)\n\n## Markata Docs\n\nNot much is documented yet, lots of work to do on the docs.  Checkout\n[LifeCycle](https://markata.dev/markata/lifecycle/) to see what a more\nfinished one looks like.\n\nUPDATE - the \n[`base_cli`](https://markata.dev/markata/plugins/base_cli/) is also up to\ndate and includes a lot of examples of how to use the markata cli.\n\n> **Yes** this library generates it's own docs\n\n* [All Modules](https://markata.dev/autodoc/)\n* [Core Modules](https://markata.dev/core_modules/)\n* [Plugins](https://markata.dev/plugins/)", "today": "2022-02-05", "now": "2022-02-05 19:38:00.891344", "datetime": null, "slug": "index", "long_description": ""}, {"cover": "", "title": "Creating your Home Page", "tags": [], "status": "draft", "templateKey": "", "path": "docs/home-page.md", "description": "There are several ways to create your home/landing page, lets walk through them.", "content": "There are several ways to create your home/landing page, lets walk through\nthem.\n\n## Default Behavior\n_feed_\n\nBy default if there is no index page, the [feed\nplugin](/markata/plugins/feeds/) will make a home page for you that simply\nlists all the the articles by title.\n\n## index.md\n_markdown_\n\nYou can also have an `index.md` in your pages directory, and it will become the\n`index.html` on at render time.  This is how [markata.dev](https://markata.dev)\nachieves it's own home page.\n\n## static/index.html\n_html_\n\nIf you want something more complicated (i.e. not easily done in markdown), you\ncan simply just make an `index.html` in your `Markata().config['assets_dir']`\nand it will become your home page. \n\n!!! note\n    your default `assets_dir` will be the static diretory in the root of your\n    project.  You can change this by adding to your `markata.toml` settings\n    file.\n\n    ```toml\n    [markata]\n    assets_dir = \"assets\"\n    ```\n\nThis is how the homepage of [waylonwalker.com](https://waylonwalker.com) is achieved.", "today": "2022-02-05", "now": "2022-02-05 19:38:00.891350", "datetime": null, "slug": "home-page", "long_description": ""}, {"title": "test_one_default_page.py", "status": "published", "slug": "tests/test_one_default_page", "path": "test_one_default_page.md", "today": "2022-02-05", "description": "Docs for test_one_default_page", "now": "2022-02-05 19:38:00.891354", "datetime": null, "long_description": "", "content": "---\n\n## make_index `function`\n\nNone\n\n??? \"make_index source\"\n    ``` python\n    def make_index(tmp_path_factory: Any) -> Any:\n        fn = tmp_path_factory.mktemp(\"pages\") / \"index.md\"\n        fn.write_text(\n            textwrap.dedent(\n                \"\"\"\n                ---\n                templateKey: blog-post\n                tags: ['python',]\n                title:  My Awesome Post\n                date: 2022-01-21T16:40:34\n                status: draft\n\n                ---\n\n                This is my awesome post.\n                \"\"\"\n            )\n        )\n        return tmp_path_factory\n    ```\n\n\n---\n\n## test_loaded `function`\n\nNone\n\n??? \"test_loaded source\"\n    ``` python\n    def test_loaded(make_index: Any) -> None:\n        os.chdir(make_index.getbasetemp())\n        m = Markata()\n        assert len(m.articles) == 1\n    ```\n\n\n---\n\n## test_run `function`\n\nNone\n\n??? \"test_run source\"\n    ``` python\n    def test_run(make_index: Any) -> Any:\n        os.chdir(make_index.getbasetemp())\n        m = Markata()\n        m.run()\n        return make_index\n    ```\n\n\n---\n\n## test_markout_exists `function`\n\nNone\n\n??? \"test_markout_exists source\"\n    ``` python\n    def test_markout_exists(test_run: Any) -> Any:\n        markout = test_run.getbasetemp() / \"markout\"\n        assert markout.exists()\n    ```\n\n\n---\n\n## test_index_exists `function`\n\nNone\n\n??? \"test_index_exists source\"\n    ``` python\n    def test_index_exists(test_run: Any) -> Any:\n        markout = test_run.getbasetemp() / \"markout\"\n        index = markout / \"index.html\"\n        assert index.exists()\n    ```\n\n\n---\n\n## test_rss_exists `function`\n\nNone\n\n??? \"test_rss_exists source\"\n    ``` python\n    def test_rss_exists(test_run: Any) -> Any:\n        markout = test_run.getbasetemp() / \"markout\"\n        rss = markout / \"rss.xml\"\n        assert rss.exists()\n    ```"}, {"title": "test_doc_page.py", "status": "published", "slug": "tests/test_doc_page", "path": "test_doc_page.md", "today": "2022-02-05", "description": "Docs for test_doc_page", "now": "2022-02-05 19:38:00.891357", "datetime": null, "long_description": "", "content": "---\n\n## make_project `function`\n\nNone\n\n??? \"make_project source\"\n    ``` python\n    def make_project(tmp_path_factory: Any) -> Any:\n        project = tmp_path_factory.mktemp(\"project\")\n        module = project / \"my_module.py\"\n        module.write_text(\n            textwrap.dedent(\n                \"\"\"\n                '''\n                Module level docstring\n                '''\n\n                def my_func():\n                    '''\n                    docstring for my_func\n                    '''\n                class MyClass:\n                    '''\n                    docstring for MyClass\n                    '''\n\n                    def my_method(self):\n                        '''\n                        docstring for my_method\n                        '''\n\n                \"\"\"\n            )\n        )\n        markta_toml = project / \"markata.toml\"\n        markta_toml.write_text(\n            textwrap.dedent(\n                \"\"\"\n                [markata]\n                hooks = [\n                    \"markata.plugins.docs\",\n                    \"default\",\n                    ]\n\n                \"\"\"\n            )\n        )\n\n        return project\n    ```\n\n\n---\n\n## test_loaded `function`\n\nNone\n\n??? \"test_loaded source\"\n    ``` python\n    def test_loaded(make_project: Any) -> None:\n        os.chdir(make_project)\n        m = Markata()\n        assert len(m.py_files) == 1\n    ```\n\n\n---\n\n## test_run `function`\n\nNone\n\n??? \"test_run source\"\n    ``` python\n    def test_run(make_project: Any) -> Any:\n        os.chdir(make_project)\n        m = Markata()\n        m.run()\n        return make_project\n    ```\n\n\n---\n\n## test_markout_exists `function`\n\nNone\n\n??? \"test_markout_exists source\"\n    ``` python\n    def test_markout_exists(test_run: Any) -> Any:\n        markout = test_run / \"markout\"\n        assert markout.exists()\n    ```\n\n\n---\n\n## test_index_exists `function`\n\nNone\n\n??? \"test_index_exists source\"\n    ``` python\n    def test_index_exists(test_run: Any) -> Any:\n        markout = test_run / \"markout\"\n        index = markout / \"index.html\"\n        assert index.exists()\n    ```\n\n\n---\n\n## test_rss_exists `function`\n\nNone\n\n??? \"test_rss_exists source\"\n    ``` python\n    def test_rss_exists(test_run: Any) -> Any:\n        markout = test_run / \"markout\"\n        rss = markout / \"rss.xml\"\n        assert rss.exists()\n    ```"}, {"title": "hookspec.py", "status": "published", "slug": "markata/hookspec", "path": "hookspec.md", "today": "2022-02-05", "description": "Docs for hookspec", "now": "2022-02-05 19:38:00.891360", "datetime": null, "long_description": "", "content": "Define hook specs.\n\n\n---\n\n## MarkataSpecs `class`\n\nNamespace that defines all specifications for Load hooks.\n\nconfigure -> glob -> load -> render -> save\n\n??? \"MarkataSpecs source\"\n    ``` python\n    class MarkataSpecs:\n        \"\"\"\n        Namespace that defines all specifications for Load hooks.\n\n        configure -> glob -> load -> render -> save\n        \"\"\"\n    ```\n\n\n---\n\n## generic_lifecycle_method `function`\n\nNone\n\n??? \"generic_lifecycle_method source\"\n    ``` python\n    def generic_lifecycle_method(\n        markata: \"Markata\",\n    ) -> Any:\n        ...\n    ```\n\n\n---\n\n## cli_lifecycle_method `function`\n\nA Markata lifecycle methos that includes a typer app used for cli's\n\n??? \"cli_lifecycle_method source\"\n    ``` python\n    def cli_lifecycle_method(markata: \"Markata\", app: \"typer.Typer\") -> Any:\n        \"A Markata lifecycle methos that includes a typer app used for cli's\"\n    ```\n\n\n---\n\n## register_attr `function`\n\nNone\n\n??? \"register_attr source\"\n    ``` python\n    def register_attr(*attrs: Any) -> Callable:\n        def decorator_register(\n            func: Callable,\n        ) -> Callable:\n\n            for attr in attrs:\n                if attr not in registered_attrs:\n                    registered_attrs[attr] = []\n                registered_attrs[attr].append(\n                    {\n                        \"func\": func,\n                        \"funcname\": func.__code__.co_name,\n                        \"lifecycle\": getattr(LifeCycle, func.__code__.co_name),\n                    }\n                )\n\n            @functools.wraps(func)\n            def wrapper_register(markata: \"Markata\", *args: Any, **kwargs: Any) -> Any:\n                return func(markata, *args, **kwargs)\n\n            return wrapper_register\n\n        return decorator_register\n    ```\n\n\n---\n\n## decorator_register `function`\n\nNone\n\n??? \"decorator_register source\"\n    ``` python\n    def decorator_register(\n            func: Callable,\n        ) -> Callable:\n\n            for attr in attrs:\n                if attr not in registered_attrs:\n                    registered_attrs[attr] = []\n                registered_attrs[attr].append(\n                    {\n                        \"func\": func,\n                        \"funcname\": func.__code__.co_name,\n                        \"lifecycle\": getattr(LifeCycle, func.__code__.co_name),\n                    }\n                )\n\n            @functools.wraps(func)\n            def wrapper_register(markata: \"Markata\", *args: Any, **kwargs: Any) -> Any:\n                return func(markata, *args, **kwargs)\n\n            return wrapper_register\n    ```\n\n\n---\n\n## wrapper_register `function`\n\nNone\n\n??? \"wrapper_register source\"\n    ``` python\n    def wrapper_register(markata: \"Markata\", *args: Any, **kwargs: Any) -> Any:\n                return func(markata, *args, **kwargs)\n    ```"}, {"title": "lifecycle.py", "status": "published", "slug": "markata/lifecycle", "path": "lifecycle.md", "today": "2022-02-05", "description": "Docs for lifecycle", "now": "2022-02-05 19:38:00.891363", "datetime": null, "long_description": "", "content": "The LifeCycle is a core component for the internal workings of Markata.  It\nsets fourth the hooks available, the methods to run them on the Markata\ninstance, and the order they run in.\n\n### Usage\n\n``` python\nfrom markata import Lifecycle\n\nstep = Lifecycle.glob\n```\n\n\n---\n\n## LifeCycle `class`\n\nLifeCycle currently supports the following steps.\n\n* configure - load and fix configuration\n* glob - find files\n* load - load files\n* pre_render - clean up files/metadata before render\n* render - render content\n* post_render - clean up rendered content\n* save - store results to disk\n\n??? \"LifeCycle source\"\n    ``` python\n    class LifeCycle(Enum):\n        \"\"\"\n        LifeCycle currently supports the following steps.\n\n        * configure - load and fix configuration\n        * glob - find files\n        * load - load files\n        * pre_render - clean up files/metadata before render\n        * render - render content\n        * post_render - clean up rendered content\n        * save - store results to disk\n\n        \"\"\"\n\n        configure = auto()\n        glob = auto()\n        load = auto()\n        pre_render = auto()\n        render = auto()\n        post_render = auto()\n        save = auto()\n\n        def __lt__(self, other: object) -> bool:\n            \"\"\"\n            Determine whether other is less than this instance.\n            \"\"\"\n            if isinstance(other, LifeCycle):\n                return self.value < other.value\n            if isinstance(other, int):\n                return self.value < other\n            return NotImplemented\n\n        def __eq__(self, other: object) -> bool:\n            \"\"\"\n            Determine whether other is equal to this instance.\n            \"\"\"\n            if isinstance(other, LifeCycle):\n                return self.value == other.value\n            if isinstance(other, int):\n                return self.value == other\n            return NotImplemented\n    ```\n\n\n---\n\n## __lt__ `method`\n\nDetermine whether other is less than this instance.\n\n??? \"__lt__ source\"\n    ``` python\n    def __lt__(self, other: object) -> bool:\n            \"\"\"\n            Determine whether other is less than this instance.\n            \"\"\"\n            if isinstance(other, LifeCycle):\n                return self.value < other.value\n            if isinstance(other, int):\n                return self.value < other\n            return NotImplemented\n    ```\n\n\n---\n\n## __eq__ `method`\n\nDetermine whether other is equal to this instance.\n\n??? \"__eq__ source\"\n    ``` python\n    def __eq__(self, other: object) -> bool:\n            \"\"\"\n            Determine whether other is equal to this instance.\n            \"\"\"\n            if isinstance(other, LifeCycle):\n                return self.value == other.value\n            if isinstance(other, int):\n                return self.value == other\n            return NotImplemented\n    ```"}, {"title": "standard_config.py", "status": "published", "slug": "markata/standard_config", "path": "standard_config.md", "today": "2022-02-05", "description": "Docs for standard_config", "now": "2022-02-05 19:38:00.891366", "datetime": null, "long_description": "", "content": "Standard Config.\nA module to load tooling config from a users project space.\n\nInspired from frustrations that some tools have a tool.ini, .tool.ini,\nsetup.cfg, or pyproject.toml.  Some allow for global configs, some don't.  Some\nproperly follow the users home directory, others end up in a weird temp\ndirectory.  Windows home directory is only more confusing.  Some will even\nrespect the users `$XDG_HOME` directory.\n\n\nThis file is for any project that can be configured in plain text such as `ini`\nor `toml` and not requiring a .py file.  Just name your tool and let users put\nconfig where it makes sense to them, no need to figure out resolution order.\n\n## Usage:\n\n``` python\nfrom standard_config import load\n\n# Retrieve any overrides from the user\noverrides = {'setting': True}\nconfig = load('my_tool', overrides)\n```\n\n## Resolution Order\n\n* First global file with a tool key\n* First local file with a tool key\n* Environment variables prefixed with `TOOL`\n* Overrides\n\n### Tool Specific Ini files\n\nIni file formats must include a `<tool>` key.\n\n``` ini\n[my_tool]\nsetting = True\n```\n\n### pyproject.toml\n\nToml files must include a `tool.<tool>` key\n\n``` toml\n[tool.my_tool]\nsetting = True\n```\n\n### setup.cfg\n\nsetup.cfg files must include a `tool:<tool>` key\n\n``` ini\n[tool:my_tool]\nsetting = True\n```\n\n\n### global files to consider\n\n* <home>/tool.ini\n* <home>/.tool\n* <home>/.tool.ini\n* <home>/.config/tool.ini\n* <home>/.config/.tool\n* <home>/.config/.tool.ini\n\n### local files to consider\n\n* <project_home>/tool.ini\n* <project_home>/.tool\n* <project_home>/.tool.ini\n* <project_home>/pyproject.toml\n* <project_home>/setup.cfg\n\n\n---\n\n## _get_global_path_specs `function`\n\nGenerate a list of standard pathspecs for global config files.\n\nArgs:\n    tool (str): name of the tool to configure\n\n??? \"_get_global_path_specs source\"\n    ``` python\n    def _get_global_path_specs(tool: str) -> path_spec_type:\n        \"\"\"\n        Generate a list of standard pathspecs for global config files.\n\n        Args:\n            tool (str): name of the tool to configure\n        \"\"\"\n        try:\n            home = Path(os.environ[\"XDG_HOME\"])\n        except KeyError:\n            home = Path.home()\n\n        return [\n            {\"path_specs\": home / f\"{tool}.ini\", \"ac_parser\": \"ini\", \"keys\": [tool]},\n            {\"path_specs\": home / f\".{tool}\", \"ac_parser\": \"ini\", \"keys\": [tool]},\n            {\"path_specs\": home / f\".{tool}.ini\", \"ac_parser\": \"ini\", \"keys\": [tool]},\n            {\n                \"path_specs\": home / \".config\" / f\"{tool}.ini\",\n                \"ac_parser\": \"ini\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": home / \".config\" / f\".{tool}\",\n                \"ac_parser\": \"ini\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": home / \".config\" / f\".{tool}.ini\",\n                \"ac_parser\": \"ini\",\n                \"keys\": [tool],\n            },\n        ]\n    ```\n\n\n---\n\n## _get_local_path_specs `function`\n\nGenerate a list of standard pathspecs for local, project directory config files.\n\nArgs:\n    tool (str): name of the tool to configure\n\n??? \"_get_local_path_specs source\"\n    ``` python\n    def _get_local_path_specs(tool: str, project_home: Union[str, Path]) -> path_spec_type:\n        \"\"\"\n        Generate a list of standard pathspecs for local, project directory config files.\n\n        Args:\n            tool (str): name of the tool to configure\n        \"\"\"\n        return [\n            {\n                \"path_specs\": Path(project_home) / f\"{tool}.ini\",\n                \"ac_parser\": \"ini\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": Path(project_home) / f\".{tool}\",\n                \"ac_parser\": \"ini\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": Path(project_home) / f\".{tool}.ini\",\n                \"ac_parser\": \"ini\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": Path(project_home) / f\"{tool}.yml\",\n                \"ac_parser\": \"yaml\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": Path(project_home) / f\".{tool}.yml\",\n                \"ac_parser\": \"yaml\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": Path(project_home) / f\"{tool}.toml\",\n                \"ac_parser\": \"toml\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": Path(project_home) / f\".{tool}.toml\",\n                \"ac_parser\": \"toml\",\n                \"keys\": [tool],\n            },\n            {\n                \"path_specs\": Path(project_home) / f\"pyproject.toml\",\n                \"ac_parser\": \"toml\",\n                \"keys\": [\"tool\", tool],\n            },\n            {\n                \"path_specs\": Path(project_home) / f\"setup.cfg\",\n                \"ac_parser\": \"ini\",\n                \"keys\": [f\"tool.{tool}\"],\n            },\n        ]\n    ```\n\n\n---\n\n## _get_attrs `function`\n\nGet nested config data from a list of keys.\n\nspecifically written for pyproject.toml which needs to get `tool` then `<tool>`\n\n??? \"_get_attrs source\"\n    ``` python\n    def _get_attrs(attrs: list, config: Dict) -> Dict:\n        \"\"\"Get nested config data from a list of keys.\n\n        specifically written for pyproject.toml which needs to get `tool` then `<tool>`\n        \"\"\"\n        for attr in attrs:\n            config = config[attr]\n        return config\n    ```\n\n\n---\n\n## _load_files `function`\n\nUse anyconfig to load config files stopping at the first one that exists.\n\nconfig_path_specs (list): a list of pathspecs and keys to load\n\n??? \"_load_files source\"\n    ``` python\n    def _load_files(config_path_specs: path_spec_type) -> Dict:\n        \"\"\"Use anyconfig to load config files stopping at the first one that exists.\n\n        config_path_specs (list): a list of pathspecs and keys to load\n        \"\"\"\n        for file in config_path_specs:\n\n            if file[\"path_specs\"].exists():\n                config = anyconfig.load(**file)\n            else:\n                # ignore missing files\n                continue\n\n            try:\n                return _get_attrs(file[\"keys\"], config)\n            except KeyError:\n                # ignore incorrect keys\n                continue\n\n        return {}\n    ```\n\n\n---\n\n## _load_env `function`\n\nLoad config from environment variables.\n\nArgs:\n    tool (str): name of the tool to configure\n\n??? \"_load_env source\"\n    ``` python\n    def _load_env(tool: str) -> Dict:\n        \"\"\"Load config from environment variables.\n\n        Args:\n            tool (str): name of the tool to configure\n        \"\"\"\n        vars = [var for var in os.environ.keys() if var.startswith(tool.upper())]\n        return {\n            var.lower().strip(tool.lower()).strip(\"_\").strip(\"-\"): os.environ[var]\n            for var in vars\n        }\n    ```\n\n\n---\n\n## load `function`\n\nLoad tool config from standard config files.\n\nResolution Order\n\n* First global file with a tool key\n* First local file with a tool key\n* Environment variables prefixed with `TOOL`\n* Overrides\n\nArgs:\n    tool (str): name of the tool to configure\n\n??? \"load source\"\n    ``` python\n    def load(tool: str, project_home: Union[Path, str] = \".\", overrides: Dict = {}) -> Dict:\n        \"\"\"Load tool config from standard config files.\n\n        Resolution Order\n\n        * First global file with a tool key\n        * First local file with a tool key\n        * Environment variables prefixed with `TOOL`\n        * Overrides\n\n        Args:\n            tool (str): name of the tool to configure\n        \"\"\"\n        global_config = _load_files(_get_global_path_specs(tool))\n        local_config = _load_files(_get_local_path_specs(tool, project_home))\n        env_config = _load_env(tool)\n        return {**global_config, **local_config, **env_config, **overrides}\n    ```"}, {"title": "__init__.py", "status": "published", "slug": "markata/__init__", "path": "__init__.md", "today": "2022-02-05", "description": "Docs for __init__", "now": "2022-02-05 19:38:00.891368", "datetime": null, "long_description": "", "content": "Markata is a tool for handling directories of markdown.\n\n\n---\n\n## Post `class`\n\nNone\n\n??? \"Post source\"\n    ``` python\n    class Post(frontmatter.Post):\n        html: str\n    ```\n\n\n---\n\n## set_phase `function`\n\nNone\n\n??? \"set_phase source\"\n    ``` python\n    def set_phase(function: Callable) -> Any:\n        def wrapper(self: Markata, *args: Tuple, **kwargs: Dict) -> Any:\n            self.phase = function.__name__\n            result = function(self, *args, **kwargs)\n            self.phase = function.__name__\n            self.phase_file.write_text(self.phase)\n            return result\n\n        return wrapper\n    ```\n\n\n---\n\n## Markata `class`\n\nNone\n\n??? \"Markata source\"\n    ``` python\n    class Markata:\n        def __init__(self, console: Console = None) -> None:\n            self.phase = \"starting\"\n            self.MARKATA_CACHE_DIR = Path(\".\") / \".markata.cache\"\n            self.MARKATA_CACHE_DIR.mkdir(exist_ok=True)\n            self.phase_file: Path = self.MARKATA_CACHE_DIR / \"phase.txt\"\n            self.registered_attrs = hookspec.registered_attrs\n            self.configure()\n            if console is not None:\n                self._console = console\n\n        @property\n        def cache(self) -> FanoutCache:\n            return FanoutCache(self.MARKATA_CACHE_DIR, statistics=True)\n\n        def __getattr__(self, item: str) -> Any:\n            if item in self.__dict__.keys():\n                return self.__getitem__(item)\n            elif item in self.registered_attrs.keys():\n                stage_to_run_to = max(\n                    [attr[\"lifecycle\"] for attr in self.registered_attrs[item]]\n                ).name\n                self.run(stage_to_run_to)\n                return getattr(self, item)\n            else:\n                raise AttributeError(item)\n\n        @property\n        def server(self) -> Server:\n            try:\n                return self._server\n            except AttributeError:\n\n                self._server: Server = Server(directory=str(self.config[\"output_dir\"]))\n                return self.server\n\n        @property\n        def runner(self) -> Runner:\n            try:\n                return self._runner\n            except AttributeError:\n\n                self._runner: Runner = Runner(self)\n                return self.runner\n\n        @property\n        def plugins(self) -> Plugins:\n            try:\n                return self._plugins\n            except AttributeError:\n\n                self._plugins: Plugins = Plugins(self)\n            return self.plugins\n\n        @property\n        def summary(self) -> Summary:\n            try:\n                return self._summary\n            except AttributeError:\n\n                self._summary: Summary = Summary(self)\n                return self.summary\n\n        def __rich__(self) -> Table:\n\n            grid = Table.grid()\n            grid.add_column(\"label\")\n            grid.add_column(\"value\")\n\n            for label, value in self.describe().items():\n                grid.add_row(label, value)\n\n            return grid\n\n        def bust_cache(self) -> Markata:\n            with self.cache as cache:\n                cache.clear()\n            return self\n\n        @set_phase\n        def configure(self) -> Markata:\n            sys.path.append(os.getcwd())\n            self.config = {**DEFUALT_CONFIG, **standard_config.load(\"markata\")}\n            if isinstance(self.config[\"glob_patterns\"], str):\n                self.config[\"glob_patterns\"] = self.config[\"glob_patterns\"].split(\",\")\n            elif isinstance(self.config[\"glob_patterns\"], list):\n                self.config[\"glob_patterns\"] = list(self.config[\"glob_patterns\"])\n            else:\n                raise TypeError(\"glob_patterns must be list or str\")\n            self.glob_patterns = self.config[\"glob_patterns\"]\n\n            if \"hooks\" not in self.config:\n                self.hooks = [\"\"]\n            if isinstance(self.config[\"hooks\"], str):\n                self.hooks = self.config[\"hooks\"].split(\",\")\n            if isinstance(self.config[\"hooks\"], list):\n                self.hooks = self.config[\"hooks\"]\n\n            if \"disabled_hooks\" not in self.config:\n                self.disabled_hooks = [\"\"]\n            if isinstance(self.config[\"disabled_hooks\"], str):\n                self.disabled_hooks = self.config[\"disabled_hooks\"].split(\",\")\n            if isinstance(self.config[\"disabled_hooks\"], list):\n                self.disabled_hooks = self.config[\"disabled_hooks\"]\n\n            try:\n                default_index = self.hooks.index(\"default\")\n                hooks = [\n                    *self.hooks[:default_index],\n                    *DEFAULT_HOOKS,\n                    *self.hooks[default_index + 1 :],\n                ]\n                self.hooks = [hook for hook in hooks if hook not in self.disabled_hooks]\n            except ValueError:\n                # 'default' is not in hooks , do not replace with default_hooks\n                pass\n\n            self._pm = pluggy.PluginManager(\"markata\")\n            self._pm.add_hookspecs(hookspec.MarkataSpecs)\n            self._register_hooks()\n\n            self._pm.hook.configure(markata=self)\n            return self\n\n        def get_plugin_config(self, path_or_name: str) -> Dict:\n\n            key = Path(path_or_name).stem\n\n            try:\n                config = self.config[key]\n            except KeyError:\n                config = {}\n            if not isinstance(config, dict):\n                raise TypeError(\"must use dict\")\n            if \"cache_expire\" not in config.keys():\n                config[\"cache_expire\"] = self.config[\"default_cache_expire\"]\n            if \"config_key\" not in config.keys():\n                config[\"config_key\"] = key\n            return config\n\n        def get_config(\n            self, key: str, warn: bool = True, suggested: Optional[str] = None\n        ) -> Any:\n            if key in self.config.keys():\n                return self.config[key]\n            else:\n\n                if suggested is None:\n                    suggested = textwrap.dedent(\n                        f\"\"\"\n                            \\[markata]\n                            {key} = value\n                        \"\"\"  # noqa: W605\n                    )\n                if warn:\n                    self.console.log(\n                        textwrap.dedent(\n                            f\"\"\"\n                            Warning site_name is not set in markata config, sitemap will\n                            be missing root site_name\n                            to resolve this open your markata.toml and add\n\n                            {suggested}\n\n                            \"\"\"\n                        ),\n                        style=\"yellow\",\n                    )\n\n        def make_hash(self, *keys: str) -> str:\n            str_keys = [str(key) for key in keys]\n            return hashlib.md5(\"\".join(str_keys).encode(\"utf-8\")).hexdigest()\n\n        @property\n        def phase(self) -> str:\n            return self._phase\n\n        @phase.setter\n        def phase(self, value: str) -> None:\n            self._phase = value\n\n        @property\n        def content_dir_hash(self) -> str:\n            hashes = [dirhash(dir) for dir in self.content_directories]\n            return self.make_hash(*hashes)\n\n        @property\n        def console(self) -> Console:\n            try:\n                return self._console\n            except AttributeError:\n                self._console = Console()\n                return self._console\n\n        def describe(self) -> dict[str, str]:\n            return {\"version\": __version__, \"phase\": self.phase}\n\n        def _to_dict(self) -> dict[str, Iterable]:\n            return {\"config\": self.config, \"articles\": [a.to_dict() for a in self.articles]}\n\n        def to_dict(self) -> dict:\n            try:\n                return self._to_dict()\n            except AttributeError:\n                self.render()\n                return self._to_dict()\n\n        def to_json(self) -> str:\n            import json\n\n            return json.dumps(self.to_dict(), indent=4, sort_keys=True, default=str)\n\n        def _register_hooks(self) -> None:\n            for hook in self.hooks:\n                try:\n                    # module style plugins\n                    plugin = importlib.import_module(hook)\n                except ModuleNotFoundError as e:\n                    # class style plugins\n                    if \".\" in hook:\n                        mod = importlib.import_module(\".\".join(hook.split(\".\")[:-1]))\n                        plugin = getattr(mod, hook.split(\".\")[-1])\n                    else:\n                        raise e\n\n                self._pm.register(plugin)\n\n        def __iter__(self, description: str = \"working...\") -> Iterable[frontmatter.Post]:\n            articles: Iterable[frontmatter.Post] = track(\n                self.articles, description=description, transient=True, console=self.console\n            )\n            return articles\n\n        def iter_articles(self, description: str) -> Iterable[frontmatter.Post]:\n            articles: Iterable[frontmatter.Post] = track(\n                self.articles, description=description, transient=True, console=self.console\n            )\n            return articles\n\n        @set_phase\n        def glob(self) -> Markata:\n            \"\"\"run glob hooks\n\n            Glob hooks should append file lists to the markata object for later\n            hooks to build from.  The default loader will utilize the `files`\n            attribute for loading.\n            \"\"\"\n\n            try:\n                self._pm.hook.glob(markata=self)\n            except AttributeError:\n                self.configure()\n                self._pm.hook.glob(markata=self)\n\n            return self\n\n        @set_phase\n        def load(self) -> Markata:\n            try:\n                self._pm.hook.load(markata=self)\n            except AttributeError:\n                self.glob()\n                self._pm.hook.load(markata=self)\n            return self\n\n        # @set_phase\n        def pre_render(self) -> Markata:\n            self._pm.hook.pre_render(markata=self)\n            return self\n\n        # @set_phase\n        def render(self) -> Markata:\n            try:\n                self._pm.hook.pre_render(markata=self)\n                self._pm.hook.render(markata=self)\n                self._pm.hook.post_render(markata=self)\n            except AttributeError:\n                self.load()\n                self._pm.hook.pre_render(markata=self)\n                self._pm.hook.render(markata=self)\n                self._pm.hook.post_render(markata=self)\n            return self\n\n        # @set_phase\n        def post_render(self) -> Markata:\n            self._pm.hook.post_render(markata=self)\n            return self\n\n        # @set_phase\n        def save(self) -> Markata:\n            try:\n                self._pm.hook.save(markata=self)\n            except AttributeError:\n                self.render()\n                self._pm.hook.save(markata=self)\n            return self\n\n        def run(self, lifecycle: LifeCycle = None) -> Markata:\n            if lifecycle is None:\n                lifecycle = getattr(LifeCycle, max(LifeCycle._member_map_))\n\n            if isinstance(lifecycle, str):\n                lifecycle = LifeCycle[lifecycle]\n\n            stages_to_run = [m for m in LifeCycle._member_map_ if LifeCycle[m] <= lifecycle]\n\n            self.console.log(f\"running {stages_to_run}\")\n            for stage in stages_to_run:\n                self.console.log(f\"{stage} running\")\n                getattr(self, stage)()\n                self.console.log(f\"{stage} complete\")\n\n            with self.cache as cache:\n                hits, misses = cache.stats()\n\n            if hits + misses > 0:\n                self.console.log(f\"cache hit rate {round(hits/ (hits + misses)*100, 2)}%\")\n            self.console.log(f\"cache hits/misses {hits}/{misses}\")\n\n            return self\n\n        def filter(self, filter: str) -> List:\n            def evalr(a: Post) -> Any:\n                try:\n                    return eval(filter, {**a.to_dict(), \"timedelta\": timedelta}, {})\n                except AttributeError:\n                    return eval(filter, {**a, \"timedelta\": timedelta}, {})\n\n            return [a for a in self.articles if evalr(a)]\n\n        def map(\n            self, func: str = \"title\", filter: str = \"True\", sort: str = \"True\"\n        ) -> List:\n            import copy\n\n            def try_sort(a: Any) -> int:\n\n                try:\n                    value = eval(sort, a.to_dict(), {})\n                except NameError:\n                    return -1\n                try:\n                    return int(value)\n                except TypeError:\n                    try:\n                        return int(value.timestamp())\n                    except Exception:\n                        try:\n                            return int(\n                                datetime.datetime.combine(\n                                    value, datetime.datetime.min.time()\n                                ).timestamp()\n                            )\n                        except Exception:\n                            try:\n                                return sum([ord(c) for c in str(value)])\n                            except Exception:\n                                return -1\n\n            articles = copy.copy(self.articles)\n            articles.sort(key=try_sort)\n            return [\n                eval(func, {**a.to_dict(), \"timedelta\": timedelta}, {})\n                for a in articles\n                if eval(filter, {**a.to_dict(), \"timedelta\": timedelta}, {})\n            ]\n    ```\n\n\n---\n\n## clif `function`\n\nNone\n\n??? \"clif source\"\n    ``` python\n    def clif() -> None:\n        import sys\n        import time\n\n        from rich import pretty, traceback\n\n        if \"--no-rich\" not in sys.argv:\n            pretty.install()\n            traceback.install()\n\n        m = Markata()\n\n        if \"--quiet\" in sys.argv or \"-q\" in sys.argv:\n            m.console.quiet = True\n        else:\n            m.console.print(\"console options:\", m.console.options)\n\n        if \"--to-dict\" in sys.argv:\n            m.console.quiet = True\n            data = m.to_dict()\n            m.console.quiet = False\n            m.console.print(data)\n            return\n\n        if \"--draft\" in sys.argv:\n            print(\"\\n\".join([a[\"path\"] for a in m.articles if a[\"status\"] == \"draft\"]))\n\n            return\n\n        if \"--today\" in sys.argv:\n            print(\"\\n\".join([a[\"path\"] for a in m.articles if a[\"date\"] == a[\"today\"]]))\n            return\n\n        if \"--scheduled\" in sys.argv:\n            print(\"\\n\".join([a[\"path\"] for a in m.articles if a[\"date\"] > a[\"today\"]]))\n            return\n\n        if \"--back-days\" in sys.argv:\n            print(\"\\n\".join([a[\"path\"] for a in m.articles if a[\"date\"] > a[\"today\"]]))\n            return\n\n        if \"--watch\" in sys.argv:\n\n            hash = m.content_dir_hash\n            m.run()\n            console = Console()\n            with console.status(\"waiting for change\", spinner=\"aesthetic\", speed=0.2):\n                while True:\n                    if m.content_dir_hash != hash:\n                        hash = m.content_dir_hash\n                        m.run()\n                    time.sleep(0.1)\n\n        m.run()\n    ```\n\n\n---\n\n## wrapper `function`\n\nNone\n\n??? \"wrapper source\"\n    ``` python\n    def wrapper(self: Markata, *args: Tuple, **kwargs: Dict) -> Any:\n            self.phase = function.__name__\n            result = function(self, *args, **kwargs)\n            self.phase = function.__name__\n            self.phase_file.write_text(self.phase)\n            return result\n    ```\n\n\n---\n\n## __init__ `method`\n\nNone\n\n??? \"__init__ source\"\n    ``` python\n    def __init__(self, console: Console = None) -> None:\n            self.phase = \"starting\"\n            self.MARKATA_CACHE_DIR = Path(\".\") / \".markata.cache\"\n            self.MARKATA_CACHE_DIR.mkdir(exist_ok=True)\n            self.phase_file: Path = self.MARKATA_CACHE_DIR / \"phase.txt\"\n            self.registered_attrs = hookspec.registered_attrs\n            self.configure()\n            if console is not None:\n                self._console = console\n    ```\n\n\n---\n\n## cache `method`\n\nNone\n\n??? \"cache source\"\n    ``` python\n    def cache(self) -> FanoutCache:\n            return FanoutCache(self.MARKATA_CACHE_DIR, statistics=True)\n    ```\n\n\n---\n\n## __getattr__ `method`\n\nNone\n\n??? \"__getattr__ source\"\n    ``` python\n    def __getattr__(self, item: str) -> Any:\n            if item in self.__dict__.keys():\n                return self.__getitem__(item)\n            elif item in self.registered_attrs.keys():\n                stage_to_run_to = max(\n                    [attr[\"lifecycle\"] for attr in self.registered_attrs[item]]\n                ).name\n                self.run(stage_to_run_to)\n                return getattr(self, item)\n            else:\n                raise AttributeError(item)\n    ```\n\n\n---\n\n## server `method`\n\nNone\n\n??? \"server source\"\n    ``` python\n    def server(self) -> Server:\n            try:\n                return self._server\n            except AttributeError:\n\n                self._server: Server = Server(directory=str(self.config[\"output_dir\"]))\n                return self.server\n    ```\n\n\n---\n\n## runner `method`\n\nNone\n\n??? \"runner source\"\n    ``` python\n    def runner(self) -> Runner:\n            try:\n                return self._runner\n            except AttributeError:\n\n                self._runner: Runner = Runner(self)\n                return self.runner\n    ```\n\n\n---\n\n## plugins `method`\n\nNone\n\n??? \"plugins source\"\n    ``` python\n    def plugins(self) -> Plugins:\n            try:\n                return self._plugins\n            except AttributeError:\n\n                self._plugins: Plugins = Plugins(self)\n            return self.plugins\n    ```\n\n\n---\n\n## summary `method`\n\nNone\n\n??? \"summary source\"\n    ``` python\n    def summary(self) -> Summary:\n            try:\n                return self._summary\n            except AttributeError:\n\n                self._summary: Summary = Summary(self)\n                return self.summary\n    ```\n\n\n---\n\n## __rich__ `method`\n\nNone\n\n??? \"__rich__ source\"\n    ``` python\n    def __rich__(self) -> Table:\n\n            grid = Table.grid()\n            grid.add_column(\"label\")\n            grid.add_column(\"value\")\n\n            for label, value in self.describe().items():\n                grid.add_row(label, value)\n\n            return grid\n    ```\n\n\n---\n\n## bust_cache `method`\n\nNone\n\n??? \"bust_cache source\"\n    ``` python\n    def bust_cache(self) -> Markata:\n            with self.cache as cache:\n                cache.clear()\n            return self\n    ```\n\n\n---\n\n## configure `method`\n\nNone\n\n??? \"configure source\"\n    ``` python\n    def configure(self) -> Markata:\n            sys.path.append(os.getcwd())\n            self.config = {**DEFUALT_CONFIG, **standard_config.load(\"markata\")}\n            if isinstance(self.config[\"glob_patterns\"], str):\n                self.config[\"glob_patterns\"] = self.config[\"glob_patterns\"].split(\",\")\n            elif isinstance(self.config[\"glob_patterns\"], list):\n                self.config[\"glob_patterns\"] = list(self.config[\"glob_patterns\"])\n            else:\n                raise TypeError(\"glob_patterns must be list or str\")\n            self.glob_patterns = self.config[\"glob_patterns\"]\n\n            if \"hooks\" not in self.config:\n                self.hooks = [\"\"]\n            if isinstance(self.config[\"hooks\"], str):\n                self.hooks = self.config[\"hooks\"].split(\",\")\n            if isinstance(self.config[\"hooks\"], list):\n                self.hooks = self.config[\"hooks\"]\n\n            if \"disabled_hooks\" not in self.config:\n                self.disabled_hooks = [\"\"]\n            if isinstance(self.config[\"disabled_hooks\"], str):\n                self.disabled_hooks = self.config[\"disabled_hooks\"].split(\",\")\n            if isinstance(self.config[\"disabled_hooks\"], list):\n                self.disabled_hooks = self.config[\"disabled_hooks\"]\n\n            try:\n                default_index = self.hooks.index(\"default\")\n                hooks = [\n                    *self.hooks[:default_index],\n                    *DEFAULT_HOOKS,\n                    *self.hooks[default_index + 1 :],\n                ]\n                self.hooks = [hook for hook in hooks if hook not in self.disabled_hooks]\n            except ValueError:\n                # 'default' is not in hooks , do not replace with default_hooks\n                pass\n\n            self._pm = pluggy.PluginManager(\"markata\")\n            self._pm.add_hookspecs(hookspec.MarkataSpecs)\n            self._register_hooks()\n\n            self._pm.hook.configure(markata=self)\n            return self\n    ```\n\n\n---\n\n## get_plugin_config `method`\n\nNone\n\n??? \"get_plugin_config source\"\n    ``` python\n    def get_plugin_config(self, path_or_name: str) -> Dict:\n\n            key = Path(path_or_name).stem\n\n            try:\n                config = self.config[key]\n            except KeyError:\n                config = {}\n            if not isinstance(config, dict):\n                raise TypeError(\"must use dict\")\n            if \"cache_expire\" not in config.keys():\n                config[\"cache_expire\"] = self.config[\"default_cache_expire\"]\n            if \"config_key\" not in config.keys():\n                config[\"config_key\"] = key\n            return config\n    ```\n\n\n---\n\n## get_config `method`\n\nNone\n\n??? \"get_config source\"\n    ``` python\n    def get_config(\n            self, key: str, warn: bool = True, suggested: Optional[str] = None\n        ) -> Any:\n            if key in self.config.keys():\n                return self.config[key]\n            else:\n\n                if suggested is None:\n                    suggested = textwrap.dedent(\n                        f\"\"\"\n                            \\[markata]\n                            {key} = value\n                        \"\"\"  # noqa: W605\n                    )\n                if warn:\n                    self.console.log(\n                        textwrap.dedent(\n                            f\"\"\"\n                            Warning site_name is not set in markata config, sitemap will\n                            be missing root site_name\n                            to resolve this open your markata.toml and add\n\n                            {suggested}\n\n                            \"\"\"\n                        ),\n                        style=\"yellow\",\n                    )\n    ```\n\n\n---\n\n## make_hash `method`\n\nNone\n\n??? \"make_hash source\"\n    ``` python\n    def make_hash(self, *keys: str) -> str:\n            str_keys = [str(key) for key in keys]\n            return hashlib.md5(\"\".join(str_keys).encode(\"utf-8\")).hexdigest()\n    ```\n\n\n---\n\n## phase `method`\n\nNone\n\n??? \"phase source\"\n    ``` python\n    def phase(self) -> str:\n            return self._phase\n    ```\n\n\n---\n\n## phase `method`\n\nNone\n\n??? \"phase source\"\n    ``` python\n    def phase(self, value: str) -> None:\n            self._phase = value\n    ```\n\n\n---\n\n## content_dir_hash `method`\n\nNone\n\n??? \"content_dir_hash source\"\n    ``` python\n    def content_dir_hash(self) -> str:\n            hashes = [dirhash(dir) for dir in self.content_directories]\n            return self.make_hash(*hashes)\n    ```\n\n\n---\n\n## console `method`\n\nNone\n\n??? \"console source\"\n    ``` python\n    def console(self) -> Console:\n            try:\n                return self._console\n            except AttributeError:\n                self._console = Console()\n                return self._console\n    ```\n\n\n---\n\n## describe `method`\n\nNone\n\n??? \"describe source\"\n    ``` python\n    def describe(self) -> dict[str, str]:\n            return {\"version\": __version__, \"phase\": self.phase}\n    ```\n\n\n---\n\n## _to_dict `method`\n\nNone\n\n??? \"_to_dict source\"\n    ``` python\n    def _to_dict(self) -> dict[str, Iterable]:\n            return {\"config\": self.config, \"articles\": [a.to_dict() for a in self.articles]}\n    ```\n\n\n---\n\n## to_dict `method`\n\nNone\n\n??? \"to_dict source\"\n    ``` python\n    def to_dict(self) -> dict:\n            try:\n                return self._to_dict()\n            except AttributeError:\n                self.render()\n                return self._to_dict()\n    ```\n\n\n---\n\n## to_json `method`\n\nNone\n\n??? \"to_json source\"\n    ``` python\n    def to_json(self) -> str:\n            import json\n\n            return json.dumps(self.to_dict(), indent=4, sort_keys=True, default=str)\n    ```\n\n\n---\n\n## _register_hooks `method`\n\nNone\n\n??? \"_register_hooks source\"\n    ``` python\n    def _register_hooks(self) -> None:\n            for hook in self.hooks:\n                try:\n                    # module style plugins\n                    plugin = importlib.import_module(hook)\n                except ModuleNotFoundError as e:\n                    # class style plugins\n                    if \".\" in hook:\n                        mod = importlib.import_module(\".\".join(hook.split(\".\")[:-1]))\n                        plugin = getattr(mod, hook.split(\".\")[-1])\n                    else:\n                        raise e\n\n                self._pm.register(plugin)\n    ```\n\n\n---\n\n## __iter__ `method`\n\nNone\n\n??? \"__iter__ source\"\n    ``` python\n    def __iter__(self, description: str = \"working...\") -> Iterable[frontmatter.Post]:\n            articles: Iterable[frontmatter.Post] = track(\n                self.articles, description=description, transient=True, console=self.console\n            )\n            return articles\n    ```\n\n\n---\n\n## iter_articles `method`\n\nNone\n\n??? \"iter_articles source\"\n    ``` python\n    def iter_articles(self, description: str) -> Iterable[frontmatter.Post]:\n            articles: Iterable[frontmatter.Post] = track(\n                self.articles, description=description, transient=True, console=self.console\n            )\n            return articles\n    ```\n\n\n---\n\n## glob `method`\n\nrun glob hooks\n\nGlob hooks should append file lists to the markata object for later\nhooks to build from.  The default loader will utilize the `files`\nattribute for loading.\n\n??? \"glob source\"\n    ``` python\n    def glob(self) -> Markata:\n            \"\"\"run glob hooks\n\n            Glob hooks should append file lists to the markata object for later\n            hooks to build from.  The default loader will utilize the `files`\n            attribute for loading.\n            \"\"\"\n\n            try:\n                self._pm.hook.glob(markata=self)\n            except AttributeError:\n                self.configure()\n                self._pm.hook.glob(markata=self)\n\n            return self\n    ```\n\n\n---\n\n## load `method`\n\nNone\n\n??? \"load source\"\n    ``` python\n    def load(self) -> Markata:\n            try:\n                self._pm.hook.load(markata=self)\n            except AttributeError:\n                self.glob()\n                self._pm.hook.load(markata=self)\n            return self\n    ```\n\n\n---\n\n## pre_render `method`\n\nNone\n\n??? \"pre_render source\"\n    ``` python\n    def pre_render(self) -> Markata:\n            self._pm.hook.pre_render(markata=self)\n            return self\n    ```\n\n\n---\n\n## render `method`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(self) -> Markata:\n            try:\n                self._pm.hook.pre_render(markata=self)\n                self._pm.hook.render(markata=self)\n                self._pm.hook.post_render(markata=self)\n            except AttributeError:\n                self.load()\n                self._pm.hook.pre_render(markata=self)\n                self._pm.hook.render(markata=self)\n                self._pm.hook.post_render(markata=self)\n            return self\n    ```\n\n\n---\n\n## post_render `method`\n\nNone\n\n??? \"post_render source\"\n    ``` python\n    def post_render(self) -> Markata:\n            self._pm.hook.post_render(markata=self)\n            return self\n    ```\n\n\n---\n\n## save `method`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(self) -> Markata:\n            try:\n                self._pm.hook.save(markata=self)\n            except AttributeError:\n                self.render()\n                self._pm.hook.save(markata=self)\n            return self\n    ```\n\n\n---\n\n## run `method`\n\nNone\n\n??? \"run source\"\n    ``` python\n    def run(self, lifecycle: LifeCycle = None) -> Markata:\n            if lifecycle is None:\n                lifecycle = getattr(LifeCycle, max(LifeCycle._member_map_))\n\n            if isinstance(lifecycle, str):\n                lifecycle = LifeCycle[lifecycle]\n\n            stages_to_run = [m for m in LifeCycle._member_map_ if LifeCycle[m] <= lifecycle]\n\n            self.console.log(f\"running {stages_to_run}\")\n            for stage in stages_to_run:\n                self.console.log(f\"{stage} running\")\n                getattr(self, stage)()\n                self.console.log(f\"{stage} complete\")\n\n            with self.cache as cache:\n                hits, misses = cache.stats()\n\n            if hits + misses > 0:\n                self.console.log(f\"cache hit rate {round(hits/ (hits + misses)*100, 2)}%\")\n            self.console.log(f\"cache hits/misses {hits}/{misses}\")\n\n            return self\n    ```\n\n\n---\n\n## filter `method`\n\nNone\n\n??? \"filter source\"\n    ``` python\n    def filter(self, filter: str) -> List:\n            def evalr(a: Post) -> Any:\n                try:\n                    return eval(filter, {**a.to_dict(), \"timedelta\": timedelta}, {})\n                except AttributeError:\n                    return eval(filter, {**a, \"timedelta\": timedelta}, {})\n\n            return [a for a in self.articles if evalr(a)]\n    ```\n\n\n---\n\n## map `method`\n\nNone\n\n??? \"map source\"\n    ``` python\n    def map(\n            self, func: str = \"title\", filter: str = \"True\", sort: str = \"True\"\n        ) -> List:\n            import copy\n\n            def try_sort(a: Any) -> int:\n\n                try:\n                    value = eval(sort, a.to_dict(), {})\n                except NameError:\n                    return -1\n                try:\n                    return int(value)\n                except TypeError:\n                    try:\n                        return int(value.timestamp())\n                    except Exception:\n                        try:\n                            return int(\n                                datetime.datetime.combine(\n                                    value, datetime.datetime.min.time()\n                                ).timestamp()\n                            )\n                        except Exception:\n                            try:\n                                return sum([ord(c) for c in str(value)])\n                            except Exception:\n                                return -1\n\n            articles = copy.copy(self.articles)\n            articles.sort(key=try_sort)\n            return [\n                eval(func, {**a.to_dict(), \"timedelta\": timedelta}, {})\n                for a in articles\n                if eval(filter, {**a.to_dict(), \"timedelta\": timedelta}, {})\n            ]\n    ```\n\n\n---\n\n## evalr `function`\n\nNone\n\n??? \"evalr source\"\n    ``` python\n    def evalr(a: Post) -> Any:\n                try:\n                    return eval(filter, {**a.to_dict(), \"timedelta\": timedelta}, {})\n                except AttributeError:\n                    return eval(filter, {**a, \"timedelta\": timedelta}, {})\n    ```\n\n\n---\n\n## try_sort `function`\n\nNone\n\n??? \"try_sort source\"\n    ``` python\n    def try_sort(a: Any) -> int:\n\n                try:\n                    value = eval(sort, a.to_dict(), {})\n                except NameError:\n                    return -1\n                try:\n                    return int(value)\n                except TypeError:\n                    try:\n                        return int(value.timestamp())\n                    except Exception:\n                        try:\n                            return int(\n                                datetime.datetime.combine(\n                                    value, datetime.datetime.min.time()\n                                ).timestamp()\n                            )\n                        except Exception:\n                            try:\n                                return sum([ord(c) for c in str(value)])\n                            except Exception:\n                                return -1\n    ```"}, {"title": "errors.py", "status": "published", "slug": "markata/errors", "path": "errors.md", "today": "2022-02-05", "description": "Docs for errors", "now": "2022-02-05 19:38:00.891371", "datetime": null, "long_description": "", "content": "---\n\n## MarkataConfigError `class`\n\nraise when markata is unable to configure correctly\n\n??? \"MarkataConfigError source\"\n    ``` python\n    class MarkataConfigError(ValueError):\n        \"\"\"\n        raise when markata is unable to configure correctly\n        \"\"\"\n    ```"}, {"title": "auto_description.py", "status": "published", "slug": "markata/plugins/auto_description", "path": "auto_description.md", "today": "2022-02-05", "description": "Docs for auto_description", "now": "2022-02-05 19:38:00.891374", "datetime": null, "long_description": "", "content": "A Markata plugin to create automatic descriptions for markdown documents.  It\ndoes this by grabbing the first `{len}` number of characters from the document\nthat are in a paragraph.\n\n## Configuration\n\nOpen up your `markata.toml` file and add new entries for your\nauto_descriptions.  You can have multiple desriptions, each one will be named\nafter the key you give it in your config.\n\n``` toml\n[markata]\nhooks=[\n   \"markata.plugins.auto_description\",\n   ]\n\n[markata.auto_description.description]\nlen=160\n[markata.auto_description.long_description]\nlen=250\n[markata.auto_description.super_description]\nlen=500\n```\n\n!!! note\n   Make sure that you have the auto_description plugin in your configured hooks.\n\nIn the above we will end up with three different descritpions, \n(`description`, `long_description`, and `super_description`) each will be the\nfirst number of characters from the document as specified in the config.\n\n### Using the Description\n\nDownstream hooks can now use the description for things such as seo, or feeds.\nHere is a simple example that lists all of the descriptions in all posts.  This\nis a handy thing you can do right from a repl.\n\n``` python\nfrom markata import Markata\nm = Markata()\n[p[\"description\"] for p in m.articles]\n```\n\n\n---\n\n## get_description `function`\n\nGet the full-length description for a single post using the commonmark\nparser.  Only paragraph nodes will count as text towards the description.\n\n??? \"get_description source\"\n    ``` python\n    def get_description(article: \"Post\") -> str:\n        \"\"\"\n        Get the full-length description for a single post using the commonmark\n        parser.  Only paragraph nodes will count as text towards the description.\n        \"\"\"\n        ast = _parser.parse(article.content)\n        return \" \".join(\n            [\n                node[0].first_child.literal\n                for node in ast.walker()\n                if node[0].t == \"paragraph\" and node[0].first_child.literal is not None\n            ]\n        )\n    ```\n\n\n---\n\n## set_description `function`\n\nFor a given `article`, find the description, put it in the cache, and set\nthe configured descriptions for the article.\n\n??? \"set_description source\"\n    ``` python\n    def set_description(\n        markata: \"Markata\", article: \"Post\", cache: \"FanoutCache\", config: Dict\n    ) -> None:\n        \"\"\"\n        For a given `article`, find the description, put it in the cache, and set\n        the configured descriptions for the article.\n        \"\"\"\n        key = markata.make_hash(\n            \"long_description\",\n            \"render\",\n            Path(__file__).read_text(),\n            article.content,\n        )\n\n        description_from_cache = cache.get(key)\n        if description_from_cache is None:\n            description = get_description(article)\n            markata.cache.add(key, description, expire=config[\"cache_expire\"])\n        else:\n            description = description_from_cache\n\n        for description_key in config:\n            if description_key not in [\"cache_expire\", \"config_key\"]:\n                if description_key not in article.metadata.keys():\n                    article.metadata[description_key] = description[\n                        : config[description_key][\"len\"]\n                    ]\n    ```\n\n\n---\n\n## pre_render `function`\n\nThe Markata hook that will set descriptions for all posts in the pre-render phase.\n\n??? \"pre_render source\"\n    ``` python\n    def pre_render(markata: \"Markata\") -> None:\n        \"\"\"\n        The Markata hook that will set descriptions for all posts in the pre-render phase.\n        \"\"\"\n        config = markata.get_plugin_config(__file__)\n        if \"description\" not in config.keys():\n            config[\"description\"] = {}\n            config[\"description\"][\"len\"] = 160\n        with markata.cache as cache:\n            for article in markata.iter_articles(\"setting auto description\"):\n                set_description(\n                    markata,\n                    article,\n                    cache,\n                    config,\n                )\n    ```"}, {"title": "copy_assets.py", "status": "published", "slug": "markata/plugins/copy_assets", "path": "copy_assets.md", "today": "2022-02-05", "description": "Docs for copy_assets", "now": "2022-02-05 19:38:00.891377", "datetime": null, "long_description": "", "content": "---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"Markata\") -> None:\n        try:\n            output_dir = Path(str(markata.config[\"output_dir\"]))\n            assets_dir = Path(str(markata.config[\"assets_dir\"]))\n        except KeyError:\n            return\n\n        with markata.console.status(\"copying assets\", spinner=\"aesthetic\", speed=0.2):\n            if assets_dir.exists():\n                shutil.copytree(assets_dir, output_dir, dirs_exist_ok=True)\n    ```"}, {"title": "auto_title.py", "status": "published", "slug": "markata/plugins/auto_title", "path": "auto_title.md", "today": "2022-02-05", "description": "Docs for auto_title", "now": "2022-02-05 19:38:00.891379", "datetime": null, "long_description": "", "content": "---\n\n## pre_render `function`\n\nNone\n\n??? \"pre_render source\"\n    ``` python\n    def pre_render(markata) -> None:\n        for article in markata.filter('title==\"\"'):\n            article[\"title\"] = (\n                Path(article[\"path\"]).stem.replace(\"-\", \" \").replace(\"_\", \" \").title()\n            )\n    ```"}, {"title": "publish_source.py", "status": "published", "slug": "markata/plugins/publish_source", "path": "publish_source.md", "today": "2022-02-05", "description": "Docs for publish_source", "now": "2022-02-05 19:38:00.891382", "datetime": null, "long_description": "", "content": "---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"Markata\") -> None:\n        output_dir = Path(str(markata.config[\"output_dir\"]))\n        output_dir.mkdir(parents=True, exist_ok=True)\n        for article in markata.iter_articles(description=\"saving source documents\"):\n            with open(\n                output_dir / Path(article[\"slug\"]).parent / Path(article[\"path\"]).name, \"w+\"\n            ) as f:\n                f.write(frontmatter.dumps(article))\n    ```"}, {"title": "covers.py", "status": "published", "slug": "markata/plugins/covers", "path": "covers.md", "today": "2022-02-05", "description": "Docs for covers", "now": "2022-02-05 19:38:00.891385", "datetime": null, "long_description": "", "content": "---\n\n## _load_font `function`\n\nNone\n\n??? \"_load_font source\"\n    ``` python\n    def _load_font(path: Path, size: int) -> ImageFont.FreeTypeFont:\n        return ImageFont.truetype(path, size=size)\n    ```\n\n\n---\n\n## get_font `function`\n\nNone\n\n??? \"get_font source\"\n    ``` python\n    def get_font(\n        path: Path,\n        draw: ImageDraw.Draw,\n        title: str,\n        size: int = 250,\n        max_size: tuple = (800, 220),\n    ) -> ImageFont.FreeTypeFont:\n        title = title or \"\"\n        font = _load_font(path, size)\n        current_size = draw.textsize(title, font=font)\n\n        if current_size[0] > max_size[0] or current_size[1] > max_size[1]:\n            return get_font(path, draw, title, size - 10, max_size=max_size)\n        return font\n    ```\n\n\n---\n\n## PaddingError `class`\n\nNone\n\n??? \"PaddingError source\"\n    ``` python\n    class PaddingError(BaseException):\n        def __init__(\n            self,\n            msg: str = \"\",\n        ) -> None:\n            super().__init__(\n                \"Padding must be an iterable of length 1, 2, 3, or 4.\\n\" + msg,\n            )\n    ```\n\n\n---\n\n## draw_text `function`\n\nNone\n\n??? \"draw_text source\"\n    ``` python\n    def draw_text(\n        image: Image,\n        font_path: Path,\n        text: str,\n        color: Union[str, None],\n        padding: Tuple[int, ...],\n    ) -> None:\n        text = text or \"\"\n        draw = ImageDraw.Draw(image)\n        padding = resolve_padding(padding)\n        width = image.size[0]\n        height = image.size[1]\n        bounding_box = [padding[0], padding[1], width - padding[0], height - padding[1]]\n        bounding_box = [padding[0], padding[1], width - padding[2], height - padding[3]]\n        max_size = (bounding_box[2] - bounding_box[0], bounding_box[3] - bounding_box[1])\n        x1, y1, x2, y2 = bounding_box\n        font = get_font(font_path, draw, text, max_size=max_size)\n        w, h = draw.textsize(text, font=font)\n        x = (x2 - x1 - w) / 2 + x1\n        y = (y2 - y1 - h) / 2 + y1\n        draw.text((x, y), text, fill=color, font=font, align=\"center\")\n    ```\n\n\n---\n\n## resolve_padding `function`\n\nConvert padding to a len 4 tuple\n\n??? \"resolve_padding source\"\n    ``` python\n    def resolve_padding(padding: Tuple[int, ...]) -> Tuple[int, ...]:\n        \"\"\"Convert padding to a len 4 tuple\"\"\"\n        if len(padding) == 4:\n            return padding\n        if len(padding) == 3:\n            return (*padding, padding[1])\n        if len(padding) == 2:\n            return padding * 2\n        if len(padding) == 1:\n            return padding * 4\n        raise PaddingError(f\"recieved padding: {padding}\")\n    ```\n\n\n---\n\n## make_cover `function`\n\nNone\n\n??? \"make_cover source\"\n    ``` python\n    def make_cover(\n        title: str,\n        color: str,\n        output_path: Path,\n        template_path: Path,\n        font_path: Path,\n        padding: Tuple[int, ...],\n        text_font: Path,\n        text: str = None,\n        text_font_color: str = None,\n        text_padding: Tuple[int, ...] = None,\n    ) -> None:\n        image = Image.open(template_path)\n        draw_text(image, font_path, title, color, padding)\n        if text is not None:\n            if text_padding is None:\n                text_padding = (\n                    image.size[1] - image.size[1] / 5,\n                    image.size[0] / 5,\n                    image.size[1] - image.size[1] / 10,\n                )\n            draw_text(image, text_font, text, text_font_color, text_padding)\n\n        output_path.parent.mkdir(exist_ok=True)\n        image.save(output_path)\n        ratio = image.size[1] / image.size[0]\n\n        covers = []\n        for width in [\n            # 32,\n            250,\n            # 500,\n        ]:\n\n            re_img = image.resize((width, int(width * ratio)), Image.ANTIALIAS)\n            filename = f\"{output_path.stem}_{width}x{int(width*ratio)}{output_path.suffix}\"\n            covers.append(filename)\n\n            filepath = Path(output_path.parent / filename)\n            re_img.save(filepath)\n    ```\n\n\n---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"Markata\") -> None:\n        futures = []\n\n        if not hasattr(markata.config, \"covers\"):\n            return\n\n        for article in markata.articles:\n            for cover in markata.config[\"covers\"]:\n                try:\n                    padding = cover[\"padding\"]\n                except KeyError:\n                    padding = (\n                        200,\n                        100,\n                    )\n                try:\n                    text_padding = cover[\"text_padding\"]\n                except KeyError:\n                    text_padding = (\n                        200,\n                        100,\n                    )\n                if \"text_key\" in cover:\n                    try:\n                        text = article.metadata[cover[\"text_key\"]]\n                    except AttributeError:\n                        text = article[cover[\"text_key\"]]\n                    try:\n                        text = text.replace(\"\\n\", \"\")\n                        from more_itertools import chunked\n\n                        text = \"\\n\".join([\"\".join(c) for c in chunked(text, 60)])\n                    except AttributeError:\n                        # text is likely None\n                        pass\n\n                    text_font = cover[\"text_font\"]\n                    text_font_color = cover[\"text_font_color\"]\n                else:\n                    text = None\n                    text_font = None\n                    text_font_color = None\n                try:\n                    title = article.metadata[\"title\"]\n                except AttributeError:\n                    title = article[\"title\"]\n                futures.append(\n                    make_cover(\n                        title=title,\n                        color=cover[\"font_color\"],\n                        output_path=Path(markata.config[\"output_dir\"])\n                        / (article[\"slug\"] + cover[\"name\"] + \".png\"),\n                        template_path=cover[\"template\"],\n                        font_path=cover[\"font\"],\n                        padding=padding,\n                        text_font=text_font,\n                        text=text,\n                        text_font_color=text_font_color,\n                        text_padding=text_padding,\n                    )\n                )\n\n        progress = Progress(\n            BarColumn(bar_width=None), transient=True, console=markata.console\n        )\n        task_id = progress.add_task(\"loading markdown\")\n        progress.update(task_id, total=len(futures))\n        with progress:\n            while not all([f.done() for f in futures]):\n                time.sleep(0.1)\n                progress.update(task_id, total=len([f for f in futures if f.done()]))\n        [f.result() for f in futures]\n    ```\n\n\n---\n\n## __init__ `method`\n\nNone\n\n??? \"__init__ source\"\n    ``` python\n    def __init__(\n            self,\n            msg: str = \"\",\n        ) -> None:\n            super().__init__(\n                \"Padding must be an iterable of length 1, 2, 3, or 4.\\n\" + msg,\n            )\n    ```"}, {"title": "to_json.py", "status": "published", "slug": "markata/plugins/to_json", "path": "to_json.md", "today": "2022-02-05", "description": "Docs for to_json", "now": "2022-02-05 19:38:00.891388", "datetime": null, "long_description": "", "content": "---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"Markata\") -> None:\n        output_file = Path(markata.config[\"output_dir\"]) / \"markata.json\"\n        output_file.parent.mkdir(parents=True, exist_ok=True)\n        output_file.write_text(json.dumps(markata.to_dict(), default=str))\n    ```"}, {"title": "tui.py", "status": "published", "slug": "markata/plugins/tui", "path": "tui.md", "today": "2022-02-05", "description": "Docs for tui", "now": "2022-02-05 19:38:00.891390", "datetime": null, "long_description": "", "content": "---\n\n## MarkataWidget `class`\n\nNone\n\n??? \"MarkataWidget source\"\n    ``` python\n    class MarkataWidget(Widget):\n        def __init__(self, markata: Markata, widget: str = \"server\"):\n            super().__init__(widget)\n            self.m = markata\n            self.widget = widget\n            self.renderable = getattr(self.m, self.widget)\n\n        def render(self):\n            return self.renderable\n\n        async def update(self, renderable: RenderableType) -> None:\n            self.renderable = renderable\n            self.refresh()\n    ```\n\n\n---\n\n## MarkataApp `class`\n\nNone\n\n??? \"MarkataApp source\"\n    ``` python\n    class MarkataApp(App):\n        async def on_mount(self) -> None:\n            self.m = Markata()\n            self.m.console.quiet = True\n            self.server = MarkataWidget(self.m, \"server\")\n            self.runner = MarkataWidget(self.m, \"runner\")\n            self.plugins = MarkataWidget(self.m, \"plugins\")\n            self.summary = MarkataWidget(self.m, \"summary\")\n            await self.view.dock(Footer(), edge=\"bottom\")\n            await self.view.dock(self.plugins, edge=\"left\", size=30, name=\"plugins\")\n            await self.view.dock(self.summary, edge=\"right\", size=30, name=\"summary\")\n            await self.view.dock(self.server, self.runner, edge=\"top\")\n            self.set_interval(1, self.action_refresh)\n\n        async def on_load(self, event):\n            await self.bind(\"q\", \"quit\", \"quit\")\n            await self.bind(\"r\", \"refresh\", \"refresh\")\n\n        async def action_refresh(self) -> None:\n            self.refresh()\n            self.runner.refresh()\n            self.server.refresh()\n            self.plugins.refresh()\n            self.summary.refresh()\n    ```\n\n\n---\n\n## cli `function`\n\nNone\n\n??? \"cli source\"\n    ``` python\n    def cli(app, markata):\n        @app.command()\n        def tui():\n            MarkataApp.run(log=\"textual.log\")\n    ```\n\n\n---\n\n## __init__ `method`\n\nNone\n\n??? \"__init__ source\"\n    ``` python\n    def __init__(self, markata: Markata, widget: str = \"server\"):\n            super().__init__(widget)\n            self.m = markata\n            self.widget = widget\n            self.renderable = getattr(self.m, self.widget)\n    ```\n\n\n---\n\n## render `method`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(self):\n            return self.renderable\n    ```\n\n\n---\n\n## tui `function`\n\nNone\n\n??? \"tui source\"\n    ``` python\n    def tui():\n            MarkataApp.run(log=\"textual.log\")\n    ```"}, {"title": "render_markdown.py", "status": "published", "slug": "markata/plugins/render_markdown", "path": "render_markdown.md", "today": "2022-02-05", "description": "Docs for render_markdown", "now": "2022-02-05 19:38:00.891393", "datetime": null, "long_description": "", "content": "---\n\n## configure `function`\n\nNone\n\n??? \"configure source\"\n    ``` python\n    def configure(markata: \"MarkataMarkdown\") -> None:\n        if \"markdown_extensions\" not in markata.config:\n            markdown_extensions = [\"\"]\n        if isinstance(markata.config[\"markdown_extensions\"], str):\n            markdown_extensions = [markata.config[\"markdown_extensions\"]]\n        if isinstance(markata.config[\"markdown_extensions\"], list):\n            markdown_extensions = markata.config[\"markdown_extensions\"]\n        else:\n            raise TypeError(\"markdown_extensions should be List[str]\")\n\n        markata.markdown_extensions = [*DEFAULT_MD_EXTENSIONS, *markdown_extensions]\n        markata.md = markdown.Markdown(extensions=markata.markdown_extensions)\n    ```\n\n\n---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: \"Markata\") -> None:\n        config = markata.get_plugin_config(__file__)\n        with markata.cache as cache:\n            for article in markata.iter_articles(\"rendering markdown\"):\n                key = markata.make_hash(\n                    \"render_markdown\",\n                    \"render\",\n                    article.content,\n                )\n                html_from_cache = cache.get(key)\n                if html_from_cache is None:\n                    html = markata.md.convert(article.content)\n                    cache.add(key, html, expire=config[\"cache_expire\"])\n                else:\n                    html = html_from_cache\n                article.html = html\n                article.article_html = html\n    ```\n\n\n---\n\n## MarkataMarkdown `class`\n\nNone\n\n??? \"MarkataMarkdown source\"\n    ``` python\n    class MarkataMarkdown(Markata):\n            articles: List = []\n            md: markdown.Markdown = markdown.Markdown()\n            markdown_extensions: List = []\n    ```"}, {"title": "pyinstrument.py", "status": "published", "slug": "markata/plugins/pyinstrument", "path": "pyinstrument.md", "today": "2022-02-05", "description": "Docs for pyinstrument", "now": "2022-02-05 19:38:00.891396", "datetime": null, "long_description": "", "content": "Markata plugin to create a pyinstrument profile if pyinstrument is installed.\n\nThe profile will be saved to <output_dir>/_profile/index.html\n\n\n---\n\n## MarkataInstrument `class`\n\nNone\n\n??? \"MarkataInstrument source\"\n    ``` python\n    class MarkataInstrument(Markata):\n        should_profile = False\n        profiler = None\n    ```\n\n\n---\n\n## configure `function`\n\nset the should_profile variable\n\n??? \"configure source\"\n    ``` python\n    def configure(markata: MarkataInstrument) -> None:\n        \"set the should_profile variable\"\n\n        if \"should_profile\" not in markata.__dict__.keys():\n            try:\n                markata.should_profile = markata.config[\"pyinstrument\"][\"should_profile\"]\n            except KeyError:\n                markata.should_profile = False\n    ```\n\n\n---\n\n## glob `function`\n\nstart the profiler as soon as possible\n\n??? \"glob source\"\n    ``` python\n    def glob(markata: MarkataInstrument) -> None:\n        \"start the profiler as soon as possible\"\n        if markata.should_profile:\n            try:\n                markata.profiler = Profiler()\n                markata.profiler.start()\n            except NameError:\n                \"ignore if Profiler does not exist\"\n                ...\n    ```\n\n\n---\n\n## save `function`\n\nstop the profiler and save as late as possible\n\n??? \"save source\"\n    ``` python\n    def save(markata: MarkataInstrument) -> None:\n        \"stop the profiler and save as late as possible\"\n        if markata.should_profile:\n            try:\n\n                if \"profiler\" in markata.__dict__.keys():\n                    output_file = (\n                        Path(markata.config[\"output_dir\"]) / \"_profile\" / \"index.html\"\n                    )\n                    output_file.parent.mkdir(parents=True, exist_ok=True)\n                    markata.profiler.stop()\n                    html = markata.profiler.output_html()\n                    output_file.write_text(html)\n                    markata.console.print(markata.profiler.output_text())\n\n            except AttributeError:\n                \"ignore if markata does not have a profiler attribute\"\n                ...\n    ```"}, {"title": "base_cli.py", "status": "published", "slug": "markata/plugins/base_cli", "path": "base_cli.md", "today": "2022-02-05", "description": "Docs for base_cli", "now": "2022-02-05 19:38:00.891399", "datetime": null, "long_description": "", "content": "Markata's base command line commands.\n\nThis plugin enables\n[`build`](https://markata.dev/markata/plugins/base_cli/#build-function)\nand\n[`list`](https://markata.dev/markata/plugins/base_cli/#list-function)\ncommands as part of the main markata cli.\n\n## Building Your Site with the Cli\n\nYour Markata Site can be build completely from the command line.\n\n``` bash\nmarkata build\n\n# or if you prefer pipx\npipx run markata build\n```\n\nsee the\n[`build`](https://markata.dev/markata/plugins/base_cli/#build-function)\nsection for more examples.\n\n## Listing your articles\n\nMarkata list is a tool to help list out artile attributes right to your\nterminal.  This is very helpful to find articles on larger sites, or\ndebug what is getting picked up by markata.\n\n``` bash\nmarkata list --map 'str(date.year) + \",\" + title'\n```\n\nsee the\n[`list`](https://markata.dev/markata/plugins/base_cli/#list-function)\nsection for more examples.\n\n\n---\n\n## make_pretty `function`\n\nThis is a helper function that enables suppresses tracebacks from\nframeworks like `click` that can make your traceback long and hard\nto follow.  It also makes evrerything more colorful and easier to\nfollow.\n\n??? \"make_pretty source\"\n    ``` python\n    def make_pretty() -> None:\n        \"\"\"\n        This is a helper function that enables suppresses tracebacks from\n        frameworks like `click` that can make your traceback long and hard\n        to follow.  It also makes evrerything more colorful and easier to\n        follow.\n        \"\"\"\n        import click\n        import pluggy\n        import typer\n        from rich import pretty as _pretty\n        from rich import traceback\n\n        _pretty.install()\n        traceback.install(\n            show_locals=True,\n            suppress=[\n                pluggy,\n                click,\n                typer,\n            ],\n        )\n    ```\n\n\n---\n\n## cli `function`\n\nMarkata hook to implement base cli commands.\n\n??? \"cli source\"\n    ``` python\n    def cli(app: typer.Typer, markata: \"Markata\") -> None:\n        \"\"\"\n        Markata hook to implement base cli commands.\n        \"\"\"\n\n        @app.command()\n        def build(\n            pretty: bool = True,\n            quiet: bool = typer.Option(\n                False,\n                \"--quiet\",\n                \"-q\",\n            ),\n            # to_dict: bool = False,\n            verbose: bool = typer.Option(\n                False,\n                \"--verbose\",\n                \"-v\",\n            ),\n            should_pdb: bool = typer.Option(\n                False,\n                \"--pdb\",\n            ),\n            profile: bool = True,\n        ) -> None:\n            \"\"\"\n            Markata's primary way of building your site for production.\n            By default, running `markta build` will render your markdown to\n            the `./markout` directory.\n\n            ``` bash\n            markata build\n            ```\n\n            If you are having an issue and want to pop immediately into a debugger\n            upon failure you can pass the `--pdb` flag to the build command.\n\n            ``` bash\n            markata build  --pdb\n            ```\n\n            If you do not like the way rich looks, or its suppressing tracebaks you\n            would like to remain visible you can use `--no-pretty`\n\n            ``` bash\n            markata build --no-pretty\n            ```\n\n            If you need to run without any console logging pass in the\n            `--quiet` flag.\n\n            ``` bash\n            markata build --quiet\n            ```\n\n            `markta build` will automatically run the pyinstrument profiler\n            while building your site if you have pyinstrument installed.  It\n            will echo out your profile in the console as well as write it to\n            `/_profile` on your built site. If you prefer not to run\n            pyinstrument profiling, even when it is installed you can pass\n            in `--no-profile`\n\n            ``` bash\n            markata build --no-profile\n            ```\n            \"\"\"\n\n            if pretty:\n                make_pretty()\n\n            if quiet:\n                markata.console.quiet = True\n\n            if verbose:\n                markata.console.print(\"console options:\", markata.console.options)\n\n            if profile:\n                markata.should_profile_cli = True\n                markata.should_profile = True\n                markata.configure()\n\n            if should_pdb:\n                pdb_run(markata.run)\n\n            else:\n                markata.run()\n\n        @app.command()\n        def list(\n            map: str = \"title\",\n            filter: str = \"True\",\n            sort: str = \"True\",\n            head: Optional[int] = None,\n            tail: Optional[int] = None,\n            include_empty: bool = False,\n            reverse: bool = False,\n            use_pager: bool = typer.Option(True, \"--pager\", \"--no-pager\"),\n        ) -> None:\n            \"\"\"\n            Provides a way run markatas, map, filter, and sort from the\n            command line.  I personally use this more often than the build\n            command while I am writing on a site with a large number of\n            posts on it.  It makes slicing in by `templatekey`, `tag`, or\n            `date` much easier.\n\n            ### default list\n\n            By default `markata list` will list all titles in a pager, for all posts\n            being loaded by markata.\n\n            ``` bash\n            markata list\n            ```\n\n            ### Skip the pager\n\n            Markata uses rich for its pager, it's pretty smart about when to\n            use the pager or pass text to the next thing in the pipeline,\n            but if you don't want to run a pager you can pass  `--no-pager`\n\n            ``` bash\n            markata list --no-pager\n            ```\n\n            ### List other attributes\n\n            You can list any other attribute tied to your posts.  These are\n            added through either your yaml frontmatter at the start of your\n            post, or through the use of a plugin.\n\n\n            ``` bash\n            # the filepath of the post\n            markata list --map path\n\n            # the slug of the post (where it will show up on the site)\n            markata list --map slug\n\n            # the date of the post\n            markata list --map date\n\n            # the full raw content of the post\n            markata list --map content\n            ```\n\n            ### List more than one attribute\n\n            You can create new attributes as you map to echo out by\n            combining existing attributes.\n\n            ``` bash\n            markata list --map 'title + \" , \" + slug'\n            ```\n\n            ### Using Python objects as map\n\n            You can access attributes of each post attribute that you map\n            over.  For instance on my blog, each post has a date that is a\n            datetime object.  I can ask each post for its `date.year`\n\n            ``` bash\n            markata list --map date.year\n\n            # combining this with title\n            markata list --map 'str(date.year) + \",\" + title'\n            ```\n\n            ### Filtering posts\n\n            Posts are filtered with python syntax, you will have all\n            attributes tied to your posts available to filter with.\n\n            ``` bash\n            markata list --filter \"'__' not in title\"\n            ```\n\n            ### Filtering by dates\n\n            If your site has dates tied to your posts you can filter by\n            date.  On my blog this makes a ton of sense and is quite useful.\n            On the Markata docs though it doesn't really make much sense,\n            since there really isn't the idea of a post date there.\n\n            ``` bash\n            # listing today's posts\n            markata list --filter \"date==today\"\n\n            # listing this year's posts\n            markata list --filter \"date.year==today.year\"\n            ```\n\n            ### Full Content Search\n\n            You can also search the full content of each post for specific\n            words.\n            ``` bash\n\n            markata list --filter \"'python' in content\"\n            ```\n\n            ### Filtering by frontmatter data\n\n            I use a templateKey on my personal blog to determine which\n            template to render the page with.  I can fitler my posts by a\n            `til` (today i learned) key.\n\n            ``` bash\n            markata list --filter \"templateKey=='til'\"\n            ```\n\n            ### Combining filters\n\n            Filters can be combined together quite like maps can, it's all\n            just python syntax.\n\n            ``` bash\n            markata list --filter \"templateKey=='til' and date == today\"\n            ```\n\n            ### Sorting posts\n\n            Posts can be sorted by attributes on your post, and they can\n            even be reversed.\n\n            ``` bash\n            markta list --sort date\n            markta list --sort date --reverse\n            ```\n\n            ### Putting it all together\n\n            The real power of all this comes when you combine them all into\n            lists that work for you and your workflow.  This really makes\n            working on larger projects so much easier to find things.\n\n\n            ### Making a fuzzy picker for your posts\n\n            Here is a bash command to open an fzf picker for todays posts,\n            then open it in your `$EDITOR`\n\n            ``` bash\n            markata list --map path --filter 'date==today' --sort date --reverse | fzf --preview 'bat --color always {}' | xargs -I {} $EDITOR {}\n            ```\n\n            ### Combining wtih nvim Telescope\n\n            Here is the same command setup as a Telescope picker for neovim.\n\n            ``` vim\n            nnoremap <leader>et <cmd>Telescope find_files find_command=markata,list,--map,path,--filter,date==today<cr>\n            ```\n\n            If you have another way to open posts in your editor with\n            `markata list` I would love to accept a PR to add it to the\n            examples here.\n            \"\"\"\n\n            markata.console.quiet = True\n\n            tail = -tail if tail else tail\n            filtered = markata.map(map, filter, sort)\n            if not include_empty:\n                filtered = [a for a in filtered if a != \"\"]\n            filtered = filtered[tail:head]\n            if reverse:\n                filtered = reversed(filtered)\n\n            markata.console.quiet = False\n            if markata.console.is_terminal and use_pager:\n                with markata.console.pager():\n                    for a in filtered:\n                        markata.console.print(a, style=\"purple\")\n            else:\n                for a in filtered:\n                    markata.console.print(a)\n    ```\n\n\n---\n\n## pdb_run `function`\n\nWraps a function call with a post_mortem pdb debugger.\n\n??? \"pdb_run source\"\n    ``` python\n    def pdb_run(func: Callable) -> None:\n        \"\"\"\n        Wraps a function call with a post_mortem pdb debugger.\n        \"\"\"\n        try:\n            func()\n        except Exception:\n            extype, value, tb = sys.exc_info()\n            traceback.print_exc()\n            pdb.post_mortem(tb)\n    ```\n\n\n---\n\n## build `function`\n\nMarkata's primary way of building your site for production.\nBy default, running `markta build` will render your markdown to\nthe `./markout` directory.\n\n``` bash\nmarkata build\n```\n\nIf you are having an issue and want to pop immediately into a debugger\nupon failure you can pass the `--pdb` flag to the build command.\n\n``` bash\nmarkata build  --pdb\n```\n\nIf you do not like the way rich looks, or its suppressing tracebaks you\nwould like to remain visible you can use `--no-pretty`\n\n``` bash\nmarkata build --no-pretty\n```\n\nIf you need to run without any console logging pass in the\n`--quiet` flag.\n\n``` bash\nmarkata build --quiet\n```\n\n`markta build` will automatically run the pyinstrument profiler\nwhile building your site if you have pyinstrument installed.  It\nwill echo out your profile in the console as well as write it to\n`/_profile` on your built site. If you prefer not to run\npyinstrument profiling, even when it is installed you can pass\nin `--no-profile`\n\n``` bash\nmarkata build --no-profile\n```\n\n??? \"build source\"\n    ``` python\n    def build(\n            pretty: bool = True,\n            quiet: bool = typer.Option(\n                False,\n                \"--quiet\",\n                \"-q\",\n            ),\n            # to_dict: bool = False,\n            verbose: bool = typer.Option(\n                False,\n                \"--verbose\",\n                \"-v\",\n            ),\n            should_pdb: bool = typer.Option(\n                False,\n                \"--pdb\",\n            ),\n            profile: bool = True,\n        ) -> None:\n            \"\"\"\n            Markata's primary way of building your site for production.\n            By default, running `markta build` will render your markdown to\n            the `./markout` directory.\n\n            ``` bash\n            markata build\n            ```\n\n            If you are having an issue and want to pop immediately into a debugger\n            upon failure you can pass the `--pdb` flag to the build command.\n\n            ``` bash\n            markata build  --pdb\n            ```\n\n            If you do not like the way rich looks, or its suppressing tracebaks you\n            would like to remain visible you can use `--no-pretty`\n\n            ``` bash\n            markata build --no-pretty\n            ```\n\n            If you need to run without any console logging pass in the\n            `--quiet` flag.\n\n            ``` bash\n            markata build --quiet\n            ```\n\n            `markta build` will automatically run the pyinstrument profiler\n            while building your site if you have pyinstrument installed.  It\n            will echo out your profile in the console as well as write it to\n            `/_profile` on your built site. If you prefer not to run\n            pyinstrument profiling, even when it is installed you can pass\n            in `--no-profile`\n\n            ``` bash\n            markata build --no-profile\n            ```\n            \"\"\"\n\n            if pretty:\n                make_pretty()\n\n            if quiet:\n                markata.console.quiet = True\n\n            if verbose:\n                markata.console.print(\"console options:\", markata.console.options)\n\n            if profile:\n                markata.should_profile_cli = True\n                markata.should_profile = True\n                markata.configure()\n\n            if should_pdb:\n                pdb_run(markata.run)\n\n            else:\n                markata.run()\n    ```\n\n\n---\n\n## list `function`\n\nProvides a way run markatas, map, filter, and sort from the\ncommand line.  I personally use this more often than the build\ncommand while I am writing on a site with a large number of\nposts on it.  It makes slicing in by `templatekey`, `tag`, or\n`date` much easier.\n\n### default list\n\nBy default `markata list` will list all titles in a pager, for all posts\nbeing loaded by markata.\n\n``` bash\nmarkata list\n```\n\n### Skip the pager\n\nMarkata uses rich for its pager, it's pretty smart about when to\nuse the pager or pass text to the next thing in the pipeline,\nbut if you don't want to run a pager you can pass  `--no-pager`\n\n``` bash\nmarkata list --no-pager\n```\n\n### List other attributes\n\nYou can list any other attribute tied to your posts.  These are\nadded through either your yaml frontmatter at the start of your\npost, or through the use of a plugin.\n\n\n``` bash\n# the filepath of the post\nmarkata list --map path\n\n# the slug of the post (where it will show up on the site)\nmarkata list --map slug\n\n# the date of the post\nmarkata list --map date\n\n# the full raw content of the post\nmarkata list --map content\n```\n\n### List more than one attribute\n\nYou can create new attributes as you map to echo out by\ncombining existing attributes.\n\n``` bash\nmarkata list --map 'title + \" , \" + slug'\n```\n\n### Using Python objects as map\n\nYou can access attributes of each post attribute that you map\nover.  For instance on my blog, each post has a date that is a\ndatetime object.  I can ask each post for its `date.year`\n\n``` bash\nmarkata list --map date.year\n\n# combining this with title\nmarkata list --map 'str(date.year) + \",\" + title'\n```\n\n### Filtering posts\n\nPosts are filtered with python syntax, you will have all\nattributes tied to your posts available to filter with.\n\n``` bash\nmarkata list --filter \"'__' not in title\"\n```\n\n### Filtering by dates\n\nIf your site has dates tied to your posts you can filter by\ndate.  On my blog this makes a ton of sense and is quite useful.\nOn the Markata docs though it doesn't really make much sense,\nsince there really isn't the idea of a post date there.\n\n``` bash\n# listing today's posts\nmarkata list --filter \"date==today\"\n\n# listing this year's posts\nmarkata list --filter \"date.year==today.year\"\n```\n\n### Full Content Search\n\nYou can also search the full content of each post for specific\nwords.\n``` bash\n\nmarkata list --filter \"'python' in content\"\n```\n\n### Filtering by frontmatter data\n\nI use a templateKey on my personal blog to determine which\ntemplate to render the page with.  I can fitler my posts by a\n`til` (today i learned) key.\n\n``` bash\nmarkata list --filter \"templateKey=='til'\"\n```\n\n### Combining filters\n\nFilters can be combined together quite like maps can, it's all\njust python syntax.\n\n``` bash\nmarkata list --filter \"templateKey=='til' and date == today\"\n```\n\n### Sorting posts\n\nPosts can be sorted by attributes on your post, and they can\neven be reversed.\n\n``` bash\nmarkta list --sort date\nmarkta list --sort date --reverse\n```\n\n### Putting it all together\n\nThe real power of all this comes when you combine them all into\nlists that work for you and your workflow.  This really makes\nworking on larger projects so much easier to find things.\n\n\n### Making a fuzzy picker for your posts\n\nHere is a bash command to open an fzf picker for todays posts,\nthen open it in your `$EDITOR`\n\n``` bash\nmarkata list --map path --filter 'date==today' --sort date --reverse | fzf --preview 'bat --color always {}' | xargs -I {} $EDITOR {}\n```\n\n### Combining wtih nvim Telescope\n\nHere is the same command setup as a Telescope picker for neovim.\n\n``` vim\nnnoremap <leader>et <cmd>Telescope find_files find_command=markata,list,--map,path,--filter,date==today<cr>\n```\n\nIf you have another way to open posts in your editor with\n`markata list` I would love to accept a PR to add it to the\nexamples here.\n\n??? \"list source\"\n    ``` python\n    def list(\n            map: str = \"title\",\n            filter: str = \"True\",\n            sort: str = \"True\",\n            head: Optional[int] = None,\n            tail: Optional[int] = None,\n            include_empty: bool = False,\n            reverse: bool = False,\n            use_pager: bool = typer.Option(True, \"--pager\", \"--no-pager\"),\n        ) -> None:\n            \"\"\"\n            Provides a way run markatas, map, filter, and sort from the\n            command line.  I personally use this more often than the build\n            command while I am writing on a site with a large number of\n            posts on it.  It makes slicing in by `templatekey`, `tag`, or\n            `date` much easier.\n\n            ### default list\n\n            By default `markata list` will list all titles in a pager, for all posts\n            being loaded by markata.\n\n            ``` bash\n            markata list\n            ```\n\n            ### Skip the pager\n\n            Markata uses rich for its pager, it's pretty smart about when to\n            use the pager or pass text to the next thing in the pipeline,\n            but if you don't want to run a pager you can pass  `--no-pager`\n\n            ``` bash\n            markata list --no-pager\n            ```\n\n            ### List other attributes\n\n            You can list any other attribute tied to your posts.  These are\n            added through either your yaml frontmatter at the start of your\n            post, or through the use of a plugin.\n\n\n            ``` bash\n            # the filepath of the post\n            markata list --map path\n\n            # the slug of the post (where it will show up on the site)\n            markata list --map slug\n\n            # the date of the post\n            markata list --map date\n\n            # the full raw content of the post\n            markata list --map content\n            ```\n\n            ### List more than one attribute\n\n            You can create new attributes as you map to echo out by\n            combining existing attributes.\n\n            ``` bash\n            markata list --map 'title + \" , \" + slug'\n            ```\n\n            ### Using Python objects as map\n\n            You can access attributes of each post attribute that you map\n            over.  For instance on my blog, each post has a date that is a\n            datetime object.  I can ask each post for its `date.year`\n\n            ``` bash\n            markata list --map date.year\n\n            # combining this with title\n            markata list --map 'str(date.year) + \",\" + title'\n            ```\n\n            ### Filtering posts\n\n            Posts are filtered with python syntax, you will have all\n            attributes tied to your posts available to filter with.\n\n            ``` bash\n            markata list --filter \"'__' not in title\"\n            ```\n\n            ### Filtering by dates\n\n            If your site has dates tied to your posts you can filter by\n            date.  On my blog this makes a ton of sense and is quite useful.\n            On the Markata docs though it doesn't really make much sense,\n            since there really isn't the idea of a post date there.\n\n            ``` bash\n            # listing today's posts\n            markata list --filter \"date==today\"\n\n            # listing this year's posts\n            markata list --filter \"date.year==today.year\"\n            ```\n\n            ### Full Content Search\n\n            You can also search the full content of each post for specific\n            words.\n            ``` bash\n\n            markata list --filter \"'python' in content\"\n            ```\n\n            ### Filtering by frontmatter data\n\n            I use a templateKey on my personal blog to determine which\n            template to render the page with.  I can fitler my posts by a\n            `til` (today i learned) key.\n\n            ``` bash\n            markata list --filter \"templateKey=='til'\"\n            ```\n\n            ### Combining filters\n\n            Filters can be combined together quite like maps can, it's all\n            just python syntax.\n\n            ``` bash\n            markata list --filter \"templateKey=='til' and date == today\"\n            ```\n\n            ### Sorting posts\n\n            Posts can be sorted by attributes on your post, and they can\n            even be reversed.\n\n            ``` bash\n            markta list --sort date\n            markta list --sort date --reverse\n            ```\n\n            ### Putting it all together\n\n            The real power of all this comes when you combine them all into\n            lists that work for you and your workflow.  This really makes\n            working on larger projects so much easier to find things.\n\n\n            ### Making a fuzzy picker for your posts\n\n            Here is a bash command to open an fzf picker for todays posts,\n            then open it in your `$EDITOR`\n\n            ``` bash\n            markata list --map path --filter 'date==today' --sort date --reverse | fzf --preview 'bat --color always {}' | xargs -I {} $EDITOR {}\n            ```\n\n            ### Combining wtih nvim Telescope\n\n            Here is the same command setup as a Telescope picker for neovim.\n\n            ``` vim\n            nnoremap <leader>et <cmd>Telescope find_files find_command=markata,list,--map,path,--filter,date==today<cr>\n            ```\n\n            If you have another way to open posts in your editor with\n            `markata list` I would love to accept a PR to add it to the\n            examples here.\n            \"\"\"\n\n            markata.console.quiet = True\n\n            tail = -tail if tail else tail\n            filtered = markata.map(map, filter, sort)\n            if not include_empty:\n                filtered = [a for a in filtered if a != \"\"]\n            filtered = filtered[tail:head]\n            if reverse:\n                filtered = reversed(filtered)\n\n            markata.console.quiet = False\n            if markata.console.is_terminal and use_pager:\n                with markata.console.pager():\n                    for a in filtered:\n                        markata.console.print(a, style=\"purple\")\n            else:\n                for a in filtered:\n                    markata.console.print(a)\n    ```"}, {"title": "load.py", "status": "published", "slug": "markata/plugins/load", "path": "load.md", "today": "2022-02-05", "description": "Docs for load", "now": "2022-02-05 19:38:00.891401", "datetime": null, "long_description": "", "content": "Default load plugin.\n\n\n---\n\n## load `function`\n\nNone\n\n??? \"load source\"\n    ``` python\n    def load(markata: \"MarkataMarkdown\") -> None:\n        progress = Progress(\n            BarColumn(bar_width=None), transient=True, console=markata.console\n        )\n\n        futures = [get_post(article, markata) for article in markata.files]\n        task_id = progress.add_task(\"loading markdown\")\n        progress.update(task_id, total=len(futures))\n        with progress:\n            while not all([f.done() for f in futures]):\n                time.sleep(0.1)\n                progress.update(task_id, total=len([f for f in futures if f.done()]))\n        articles = [f.result() for f in futures]\n        articles = [a for a in articles if a]\n        markata.articles = articles\n    ```\n\n\n---\n\n## get_post `function`\n\nNone\n\n??? \"get_post source\"\n    ``` python\n    def get_post(path: Path, markata: \"Markata\") -> Optional[Callable]:\n        # -> Optional[\"Post\"]:\n        default = {\n            \"cover\": \"\",\n            \"title\": \"\",\n            \"tags\": [],\n            \"status\": \"draft\",\n            \"templateKey\": \"\",\n            \"path\": str(path),\n            \"description\": \"\",\n            \"content\": \"\",\n        }\n        try:\n            post: \"Post\" = frontmatter.load(path)\n            post.metadata = {**default, **post.metadata}\n        except ParserError:\n            return None\n            post = default\n        except ValueError:\n            return None\n            post = default\n        post.metadata[\"path\"] = str(path)\n        return post\n    ```\n\n\n---\n\n## MarkataMarkdown `class`\n\nNone\n\n??? \"MarkataMarkdown source\"\n    ``` python\n    class MarkataMarkdown(Markata):\n            articles: List = []\n    ```"}, {"title": "sitemap.py", "status": "published", "slug": "markata/plugins/sitemap", "path": "sitemap.md", "today": "2022-02-05", "description": "Docs for sitemap", "now": "2022-02-05 19:38:00.891404", "datetime": null, "long_description": "", "content": "---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: Markata) -> None:\n        url = markata.get_config(\"url\") or \"\"\n\n        sitemap = {\n            \"urlset\": [\n                {\n                    \"url\": {\n                        \"loc\": url + \"/\" + article[\"slug\"] + \"/\",\n                        \"changefreq\": \"daily\",\n                        \"priority\": \"0.7\",\n                    }\n                }\n                for article in markata.articles\n                if article[\"status\"] == \"published\"\n            ]\n        }\n\n        sitemap = (\n            anyconfig.dumps(sitemap, \"xml\")\n            .decode(\"utf-8\")\n            .replace(\n                \"<urlset>\",\n                '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:mobile=\"http://www.google.com/schemas/sitemap-mobile/1.0\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">',\n            )\n            .replace(\"</url>\", \"</url>\\n\")\n        )\n        setattr(markata, \"sitemap\", sitemap)\n    ```\n\n\n---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: Markata) -> None:\n        with open(Path(markata.config[\"output_dir\"]) / \"sitemap.xml\", \"w\") as f:\n            f.write(markata.sitemap)\n    ```"}, {"title": "long_description.py", "status": "published", "slug": "markata/plugins/long_description", "path": "long_description.md", "today": "2022-02-05", "description": "Docs for long_description", "now": "2022-02-05 19:38:00.891407", "datetime": null, "long_description": "", "content": "---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: \"Markata\") -> None:\n        config = markata.get_plugin_config(__file__)\n        with markata.cache as cache:\n            for article in markata.iter_articles(\"setting long description\"):\n\n                key = markata.make_hash(\n                    \"long_description\",\n                    \"render\",\n                    Path(__file__).read_text(),\n                    article.content,\n                    article.html,\n                )\n\n                description_from_cache = cache.get(key)\n\n                if description_from_cache is None:\n\n                    if \"long_description\" in article.metadata:\n                        description = article.metadata[\"long_description\"]\n\n                    else:\n                        try:\n                            soup = BeautifulSoup(article.html, features=\"lxml\")\n                            description = \" \".join(\n                                [p.text for p in soup.find(id=\"post-body\").find_all(\"p\")]\n                            ).strip()[:250]\n                        except AttributeError:\n                            description = \"\"\n\n                    markata.cache.add(key, description, expire=config[\"cache_expire\"])\n\n                else:\n                    description = description_from_cache\n\n                article.metadata[\"long_description\"] = description\n    ```"}, {"title": "flat_slug.py", "status": "published", "slug": "markata/plugins/flat_slug", "path": "flat_slug.md", "today": "2022-02-05", "description": "Docs for flat_slug", "now": "2022-02-05 19:38:00.891410", "datetime": null, "long_description": "", "content": "Flat Slug Plugin\n\nCreates a slug in article.metadata if missing based on filename.\n\n\n---\n\n## pre_render `function`\n\nNone\n\n??? \"pre_render source\"\n    ``` python\n    def pre_render(markata: \"Markata\") -> None:\n        for article in markata.iter_articles(description=\"creating slugs\"):\n            try:\n                article[\"slug\"] = article.metadata[\"slug\"]\n            except KeyError:\n                article[\"slug\"] = Path(article[\"path\"]).stem\n    ```"}, {"title": "seo.py", "status": "published", "slug": "markata/plugins/seo", "path": "seo.md", "today": "2022-02-05", "description": "Docs for seo", "now": "2022-02-05 19:38:00.891412", "datetime": null, "long_description": "", "content": "manifest plugin\n\n\n---\n\n## _create_seo `function`\n\nNone\n\n??? \"_create_seo source\"\n    ``` python\n    def _create_seo(\n        markata: Markata,\n        soup: BeautifulSoup,\n        article: \"frontmatter.Post\",\n        site_name: str,\n        author_name: str,\n        author_email: str,\n        twitter_card: str,\n        twitter_creator: str,\n        config_seo: Dict,\n        images_url: str,\n    ) -> List:\n        if article.metadata[\"description\"] == \"\" or None:\n            try:\n                article.metadata[\"description\"] = \" \".join(\n                    [p.text for p in soup.find(id=\"post-body\").find_all(\"p\")]\n                ).strip()[:120]\n            except AttributeError:\n                article.metadata[\"description\"] = \"\"\n\n        seo = [\n            *config_seo,\n            {\n                \"name\": \"og:author\",\n                \"property\": \"og:author\",\n                \"content\": author_name,\n            },\n            {\n                \"name\": \"og:author_email\",\n                \"property\": \"og:author_email\",\n                \"content\": author_email,\n            },\n            {\n                \"name\": \"og:type\",\n                \"property\": \"og:type\",\n                \"content\": \"website\",\n            },\n            {\n                \"name\": \"description\",\n                \"property\": \"description\",\n                \"content\": article.metadata[\"description\"],\n            },\n            {\n                \"name\": \"og:description\",\n                \"property\": \"og:description\",\n                \"content\": article.metadata[\"description\"],\n            },\n            {\n                \"name\": \"twitter:description\",\n                \"property\": \"twitter:description\",\n                \"content\": article.metadata[\"description\"],\n            },\n            {\n                \"name\": \"og:title\",\n                \"property\": \"og:title\",\n                \"content\": f'{article.metadata[\"title\"]} | {site_name}'[:60],\n            },\n            {\n                \"name\": \"twitter:title\",\n                \"property\": \"twitter:title\",\n                \"content\": f'{article.metadata[\"title\"]} | {site_name}'[:60],\n            },\n            {\n                \"name\": \"og:image\",\n                \"property\": \"og:image\",\n                \"content\": f'{images_url}/{article.metadata[\"slug\"]}-og.png',\n            },\n            {\n                \"name\": \"twitter:image\",\n                \"property\": \"twitter:image\",\n                \"content\": f'{images_url}/{article.metadata[\"slug\"]}-og.png',\n            },\n            {\n                \"name\": \"og:image:width\",\n                \"property\": \"og:image:width\",\n                \"content\": \"1600\",\n            },\n            {\n                \"name\": \"og:image:width\",\n                \"property\": \"og:image:width\",\n                \"content\": \"900\",\n            },\n            {\n                \"name\": \"twitter:card\",\n                \"property\": \"twitter:card\",\n                \"content\": twitter_card,\n            },\n            {\n                \"name\": \"og:site_name\",\n                \"property\": \"og:site_name\",\n                \"content\": site_name,\n            },\n            {\n                \"name\": \"twitter:creator\",\n                \"property\": \"twitter:creator\",\n                \"content\": twitter_creator,\n            },\n            {\n                \"name\": \"title\",\n                \"property\": \"title\",\n                \"content\": article.metadata[\"title\"],\n            },\n            {\n                \"name\": \"generator\",\n                \"property\": \"generator\",\n                \"content\": f\"markata {__version__}\",\n            },\n        ]\n        return seo\n    ```\n\n\n---\n\n## _add_seo_tags `function`\n\nNone\n\n??? \"_add_seo_tags source\"\n    ``` python\n    def _add_seo_tags(seo: List, article: \"frontmatter.Post\", soup: BeautifulSoup) -> None:\n        for meta in seo:\n            soup.head.append(_create_seo_tag(meta, soup))\n    ```\n\n\n---\n\n## _create_seo_tag `function`\n\nNone\n\n??? \"_create_seo_tag source\"\n    ``` python\n    def _create_seo_tag(meta: dict, soup: BeautifulSoup) -> \"Tag\":\n        tag = soup.new_tag(\"meta\")\n        for k in meta:\n            tag.attrs[k] = meta[k]\n        return tag\n    ```\n\n\n---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: Markata) -> None:\n\n        url = markata.get_config(\"url\") or \"\"\n        images_url = markata.get_config(\"images_url\") or url or \"\"\n        site_name = markata.get_config(\"site_name\") or \"\"\n        author_name = markata.get_config(\"author_name\") or \"\"\n        author_email = markata.get_config(\"author_email\") or \"\"\n        twitter_creator = markata.get_config(\"twitter_creator\") or \"\"\n        twitter_card = markata.get_config(\"twitter_card\") or \"summary_large_image\"\n        config_seo = markata.get_config(\"seo\", warn=False) or dict()\n\n        with markata.cache as cache:\n            for article in markata.iter_articles(\"add seo tags from seo.py\"):\n                key = markata.make_hash(\n                    \"seo\",\n                    \"render\",\n                    article.html,\n                    site_name,\n                    url,\n                    article.metadata[\"slug\"],\n                    twitter_card,\n                    article.metadata[\"title\"],\n                    str(config_seo),\n                )\n\n                html_from_cache = cache.get(key)\n\n                if html_from_cache is None:\n                    soup = BeautifulSoup(article.html, features=\"lxml\")\n                    seo = _create_seo(\n                        markata=markata,\n                        soup=soup,\n                        article=article,\n                        site_name=site_name,\n                        author_name=author_name,\n                        author_email=author_email,\n                        twitter_card=twitter_card,\n                        twitter_creator=twitter_creator,\n                        config_seo=config_seo,\n                        images_url=images_url,\n                    )\n                    _add_seo_tags(seo, article, soup)\n                    canonical_link = soup.new_tag(\"link\")\n                    canonical_link.attrs[\"rel\"] = \"canonical\"\n                    if article.metadata[\"slug\"] == \"index\":\n                        canonical_link.attrs[\"href\"] = f\"{url}/\"\n                    else:\n                        canonical_link.attrs[\"href\"] = f'{url}/{article.metadata[\"slug\"]}/'\n                    soup.head.append(canonical_link)\n\n                    meta_url = soup.new_tag(\"meta\")\n                    meta_url.attrs[\"name\"] = \"og:url\"\n                    meta_url.attrs[\"property\"] = \"og:url\"\n                    if article.metadata[\"slug\"] == \"index\":\n                        meta_url.attrs[\"content\"] = f\"{url}/\"\n                    else:\n                        meta_url.attrs[\"content\"] = f'{url}/{article.metadata[\"slug\"]}/'\n                    soup.head.append(meta_url)\n\n                    html = soup.prettify()\n                    cache.add(key, html, expire=markata.config[\"default_cache_expire\"])\n\n                else:\n                    html = html_from_cache\n                article.html = html\n    ```"}, {"title": "heading_link.py", "status": "published", "slug": "markata/plugins/heading_link", "path": "heading_link.md", "today": "2022-02-05", "description": "Docs for heading_link", "now": "2022-02-05 19:38:00.891415", "datetime": null, "long_description": "", "content": "Creates links next to all heading tags to make it easier for users to share a\nspecific heading.\n\n\n---\n\n## post_render `function`\n\nThis plugin creates a link svg next to all headings.\n\n??? \"post_render source\"\n    ``` python\n    def post_render(markata: Markata) -> None:\n        \"\"\"\n        This plugin creates a link svg next to all headings.\n        \"\"\"\n\n        config = markata.get_plugin_config(__file__)\n        with markata.cache as cache:\n            for article in markata.iter_articles(\"link headers\"):\n\n                key = markata.make_hash(\n                    \"heading_link\",\n                    \"post_render\",\n                    Path(__file__).read_text(),\n                    article.content,\n                    article.html,\n                )\n\n                html_from_cache = cache.get(key)\n\n                if html_from_cache is None:\n                    html = link_headings(article)\n                    cache.add(key, html, expire=config[\"cache_expire\"])\n                else:\n                    html = html_from_cache\n                article.html = html\n    ```\n\n\n---\n\n## link_headings `function`\n\nUse BeautifulSoup to find all headings and run link_heading on them.\n\n??? \"link_headings source\"\n    ``` python\n    def link_headings(article: \"Post\") -> Any:\n        \"\"\"\n        Use BeautifulSoup to find all headings and run link_heading on them.\n        \"\"\"\n        soup = BeautifulSoup(article.html, features=\"lxml\")\n        for heading in soup.find_all(re.compile(\"^h[1-6]$\")):\n            if not heading.find(\"a\", {\"class\": \"heading-permalink\"}):\n                link_heading(soup, heading)\n        html = soup.prettify()\n        return html\n    ```\n\n\n---\n\n## link_heading `function`\n\nMutate soup to include an svg link at the heading passed in.\n\n??? \"link_heading source\"\n    ``` python\n    def link_heading(soup: \"bs4.BeautifulSoup\", heading: \"bs4.element.Tag\") -> None:\n        \"\"\"\n        Mutate soup to include an svg link at the heading passed in.\n        \"\"\"\n        id = heading.get(\"id\")\n\n        link = soup.new_tag(\"a\", href=f\"#{id}\", **{\"class\": \"heading-permalink\"})\n        span = soup.new_tag(\"span\", **{\"class\": \"visually-hidden\"})\n        svg = soup.new_tag(\n            \"svg\",\n            fill=\"currentColor\",\n            focusable=\"false\",\n            width=\"1em\",\n            height=\"1em\",\n            xmlns=\"http://www.w3.org/2000/svg\",\n            viewBox=\"0 0 24 24\",\n            **{\n                \"aria-hidden\": \"true\",\n            },\n        )\n\n        path = soup.new_tag(\n            \"path\",\n            d=\"M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z\",\n        )\n        svg.append(path)\n        link.append(span)\n        link.append(svg)\n        heading.append(link)\n    ```"}, {"title": "publish_html.py", "status": "published", "slug": "markata/plugins/publish_html", "path": "publish_html.md", "today": "2022-02-05", "description": "Docs for publish_html", "now": "2022-02-05 19:38:00.891418", "datetime": null, "long_description": "", "content": "---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"Markata\") -> None:\n        output_dir = Path(markata.config[\"output_dir\"])  # type: ignore\n        output_dir.mkdir(parents=True, exist_ok=True)\n\n        for article in markata.articles:\n            if article[\"slug\"] == \"index\":\n                article_path = output_dir / \"index.html\"\n            else:\n                article_path = output_dir / article[\"slug\"] / \"index.html\"\n            article_path.parent.mkdir(parents=True, exist_ok=True)\n            with open(article_path, \"w+\") as f:\n                f.write(article.html)\n    ```"}, {"title": "icon_resize.py", "status": "published", "slug": "markata/plugins/icon_resize", "path": "icon_resize.md", "today": "2022-02-05", "description": "Docs for icon_resize", "now": "2022-02-05 19:38:00.891421", "datetime": null, "long_description": "", "content": "Icon Resize Plugin\n\n\n---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: \"MarkataIcons\") -> None:\n        if \"icon\" not in markata.config:\n            return\n        base_out_file = Path(markata.config[\"output_dir\"]) / markata.config[\"icon\"]\n\n        with Image.open(Path(markata.config[\"assets_dir\"]) / markata.config[\"icon\"]) as img:\n            markata.icons = []\n            for width in [48, 72, 96, 144, 192, 256, 384, 512]:\n                height = int(float(img.size[1]) * float(width / float(img.size[0])))\n                filename = Path(\n                    f\"{base_out_file.stem}_{width}x{height}{base_out_file.suffix}\"\n                )\n                markata.icons.append(\n                    {\n                        \"src\": str(filename),\n                        \"sizes\": f\"{width}x{width}\",\n                        \"type\": f\"image/{img.format}\".lower(),\n                        \"purpose\": \"any maskable\",\n                    }\n                )\n    ```\n\n\n---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"MarkataIcons\") -> None:\n        if \"icon\" not in markata.config:\n            return\n        base_out_file = Path(markata.config[\"output_dir\"]) / markata.config[\"icon\"]\n        for width in [48, 72, 96, 144, 192, 256, 384, 512]:\n            with Image.open(\n                Path(markata.config[\"assets_dir\"]) / markata.config[\"icon\"]\n            ) as img:\n                height = int(float(img.size[1]) * float(width / float(img.size[0])))\n                img = img.resize((width, height), Image.ANTIALIAS)\n                filename = Path(\n                    f\"{base_out_file.stem}_{width}x{height}{base_out_file.suffix}\"\n                )\n                out_file = Path(markata.config[\"output_dir\"]) / filename\n                img.save(out_file)\n    ```\n\n\n---\n\n## MarkataIcons `class`\n\nNone\n\n??? \"MarkataIcons source\"\n    ``` python\n    class MarkataIcons(Markata):\n            icons: List[Dict[str, str]]\n    ```"}, {"title": "docs.py", "status": "published", "slug": "markata/plugins/docs", "path": "docs.md", "today": "2022-02-05", "description": "Docs for docs", "now": "2022-02-05 19:38:00.891423", "datetime": null, "long_description": "", "content": "leading docstring\n\n\n---\n\n## add_parents `function`\n\nNone\n\n??? \"add_parents source\"\n    ``` python\n    def add_parents(tree: ast.AST) -> None:\n        for node in ast.walk(tree):\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n                if not hasattr(child, \"parents\"):\n                    child.parents = [node]\n                child.parents.append(node)\n                if isinstance(node, ast.ClassDef) and isinstance(child, ast.FunctionDef):\n                    child.type = \"method\"\n                elif isinstance(child, ast.FunctionDef):\n                    child.type = \"function\"\n                elif isinstance(child, ast.ClassDef):\n                    child.type = \"class\"\n    ```\n\n\n---\n\n## glob `function`\n\nfinds k\n\n## Parameters\n\n`markata` the markata object\n\n??? \"glob source\"\n    ``` python\n    def glob(markata: \"MarkataDocs\") -> None:\n        \"\"\"\n        finds k\n\n        ## Parameters\n\n        `markata` the markata object\n\n        \"\"\"\n\n        markata.py_files = list(Path().glob(\"**/*.py\"))\n\n        content_directories = list(set([f.parent for f in markata.py_files]))\n        if \"content_directories\" in markata.__dict__.keys():\n            markata.content_directories.extend(content_directories)\n        else:\n            markata.content_directories = content_directories\n\n        try:\n            ignore = markata.config[\"glob\"][\"use_gitignore\"] or True\n        except KeyError:\n            ignore = True\n\n        if ignore and (Path(\".gitignore\").exists() or Path(\".markataignore\").exists()):\n            import pathspec\n\n            lines = []\n\n            if Path(\".gitignore\").exists():\n                lines.extend(Path(\".gitignore\").read_text().splitlines())\n\n            if Path(\".markataignore\").exists():\n                lines.extend(Path(\".markataignore\").read_text().splitlines())\n\n            spec = pathspec.PathSpec.from_lines(\"gitwildmatch\", lines)\n\n            markata.py_files = [\n                file for file in markata.py_files if not spec.match_file(str(file))\n            ]\n    ```\n\n\n---\n\n## make_article `function`\n\nNone\n\n??? \"make_article source\"\n    ``` python\n    def make_article(file: Path) -> frontmatter.Post:\n        raw_source = file.read_text()\n        tree = ast.parse(raw_source)\n        add_parents(tree)\n        nodes = [\n            n\n            for n in ast.walk(tree)\n            if isinstance(n, ast.FunctionDef) or isinstance(n, ast.ClassDef)\n        ]\n        article = textwrap.dedent(\n            f\"\"\"\n        ---\n        title: {file.name}\n        status: published\n        slug: {file.parent}/{file.stem}\n        path: {file.stem}.md\n        today: {datetime.datetime.today()}\n        description: Docs for {file.stem}\n\n        ---\n\n        \"\"\"\n        )\n        article += textwrap.dedent(\n            f\"\"\"\n                {ast.get_docstring(tree) or \"\"}\n                \"\"\"\n        )\n        for node in nodes:\n            article += textwrap.dedent(\n                f\"\"\"\n\n    ---\n\n    ## {node.name} `{node.type}`\n\n    {ast.get_docstring(node)}\n\n    ??? \"{node.name} source\"\n        ``` python\n    {textwrap.indent(ast.get_source_segment(raw_source, node), '    ')}\n        ```\n            \"\"\"\n            )\n\n        return frontmatter.loads(article)\n    ```\n\n\n---\n\n## load `function`\n\nsimilar to [glob](../glob)\n\n??? \"load source\"\n    ``` python\n    def load(markata: \"MarkataDocs\") -> None:\n        \"\"\"\n        similar to [glob](../glob)\n        \"\"\"\n        if \"articles\" not in markata.__dict__:\n            markata.articles = []\n        for py_file in markata.py_files:\n            markata.articles.append(make_article(py_file))\n    ```\n\n\n---\n\n## MarkataDocs `class`\n\nNone\n\n??? \"MarkataDocs source\"\n    ``` python\n    class MarkataDocs(Markata):\n            py_files: List = []\n            content_directories: List = []\n    ```"}, {"title": "post_template.py", "status": "published", "slug": "markata/plugins/post_template", "path": "post_template.md", "today": "2022-02-05", "description": "Docs for post_template", "now": "2022-02-05 19:38:00.891426", "datetime": null, "long_description": "", "content": "---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: \"Markata\") -> None:\n        if \"post_template\" in markata.config:\n            template_file = markata.config[\"post_template\"]\n        else:\n            template_file = Path(__file__).parent / \"default_post_template.html\"\n        with open(template_file) as f:\n            template = Template(f.read())\n        for article in markata.iter_articles(\"apply template\"):\n\n            article.html = template.render(\n                body=article.html,\n                toc=markata.md.toc,  # type: ignore\n                **article,\n            )\n    ```"}, {"title": "create_covers.py", "status": "published", "slug": "markata/plugins/create_covers", "path": "create_covers.md", "today": "2022-02-05", "description": "Docs for create_covers", "now": "2022-02-05 19:38:00.891429", "datetime": null, "long_description": "", "content": "---\n\n## get_font `function`\n\nNone\n\n??? \"get_font source\"\n    ``` python\n    def get_font(\n        path: Path, draw: ImageDraw.Draw, title: str, size: int = 250\n    ) -> ImageFont.FreeTypeFont:\n        font = ImageFont.truetype(path, size=size)\n        if draw.textsize(title, font=font)[0] > 800:\n            return get_font(path, draw, title, size - 10)\n        return font\n    ```\n\n\n---\n\n## make_cover `function`\n\nNone\n\n??? \"make_cover source\"\n    ``` python\n    def make_cover(\n        title: str, color: str, output_path: Path, template_path: Path, font_path: Path\n    ) -> None:\n        image = Image.open(template_path)\n\n        draw = ImageDraw.Draw(image)\n\n        font = get_font(font_path, draw, title)\n\n        color = \"rgb(255,255,255)\"\n        padding = (200, 100)\n        bounding_box = [padding[0], padding[1], 1000 - padding[0], 420 - padding[1]]\n        x1, y1, x2, y2 = bounding_box\n        w, h = draw.textsize(title, font=font)\n        x = (x2 - x1 - w) / 2 + x1\n        y = (y2 - y1 - h) / 2 + y1\n        draw.text((x, y), title, fill=color, font=font, align=\"center\")\n        image.save(output_path)\n    ```\n\n\n---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"Markata\") -> None:\n        for article in markata.articles:\n            output_path = Path(markata.output_dir) / (\n                Path(article.metadata[\"path\"]).stem + \".png\"\n            )\n\n            make_cover(\n                article.metadata[\"title\"],\n                markata.config[\"cover_font_color\"],\n                output_path,\n                markata.config[\"cover_template\"],\n                markata.config[\"cover_font\"],\n            )\n    ```"}, {"title": "manifest.py", "status": "published", "slug": "markata/plugins/manifest", "path": "manifest.md", "today": "2022-02-05", "description": "Docs for manifest", "now": "2022-02-05 19:38:00.891431", "datetime": null, "long_description": "", "content": "manifest plugin\n\n\n---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: \"MarkataIcons\") -> None:\n        if \"icons\" in markata.__dict__.keys():\n            icons = markata.icons\n        else:\n            icons = []\n        manifest = {\n            \"name\": markata.get_config(\"site_name\") or \"\",\n            \"short_name\": markata.get_config(\"short_name\") or \"\",\n            \"start_url\": markata.get_config(\"start_url\") or \"\",\n            \"display\": markata.get_config(\"display\") or \"\",\n            \"background_color\": markata.get_config(\"background_color\") or \"\",\n            \"theme_color\": markata.get_config(\"theme_color\") or \"\",\n            \"description\": markata.get_config(\"description\") or \"\",\n            \"icons\": icons,\n        }\n        filepath = Path(markata.config[\"output_dir\"]) / \"manifest.json\"\n        filepath.parent.mkdir(parents=True, exist_ok=True)\n        filepath.touch(exist_ok=True)\n        with open(filepath, \"w+\") as f:\n            json.dump(manifest, f, ensure_ascii=True, indent=4)\n        config = markata.get_plugin_config(__file__)\n        with markata.cache as cache:\n            for article in markata.iter_articles(\"add manifest link\"):\n                key = markata.make_hash(\n                    \"seo\",\n                    \"manifest\",\n                    article.content,\n                    article.html,\n                )\n                html_from_cache = cache.get(key)\n\n                if html_from_cache is None:\n                    soup = BeautifulSoup(article.html, features=\"lxml\")\n                    link = soup.new_tag(\"link\")\n                    link.attrs[\"rel\"] = \"manifest\"\n                    link.attrs[\"href\"] = \"/manifest.json\"\n                    soup.head.append(link)\n\n                    html = soup.prettify()\n                    cache.add(key, html, expire=config[\"cache_expire\"])\n                else:\n                    html = html_from_cache\n                article.html = html\n    ```"}, {"title": "generator.py", "status": "published", "slug": "markata/plugins/generator", "path": "generator.md", "today": "2022-02-05", "description": "Docs for generator", "now": "2022-02-05 19:38:00.891434", "datetime": null, "long_description": "", "content": "add generator meta tag\n\n\n---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: Markata) -> None:\n        for article in markata.iter_articles(\"add ssg tag\"):\n            soup = BeautifulSoup(article.html, features=\"lxml\")\n            tag = soup.new_tag(\"meta\")\n            tag.attrs[\"content\"] = f\"markata {__version__}\"\n            tag.attrs[\"name\"] = \"generator\"\n            soup.head.append(tag)\n            article.soup = soup\n            article.html = soup.prettify()\n    ```"}, {"title": "datetime.py", "status": "published", "slug": "markata/plugins/datetime", "path": "datetime.md", "today": "2022-02-05", "description": "Docs for datetime", "now": "2022-02-05 19:38:00.891437", "datetime": null, "long_description": "", "content": "Default datetime plugin\n\n\n---\n\n## load `function`\n\nNone\n\n??? \"load source\"\n    ``` python\n    def load(markata: \"Markata\") -> None:\n        for article in markata.iter_articles(\"datetime\"):\n\n            try:\n                date = article.metadata[\"date\"]\n            except KeyError:\n                date = None\n            if isinstance(date, str):\n                date = dateutil.parser.parse(date)\n            if isinstance(date, datetime.date):\n                date = datetime.datetime(\n                    year=date.year,\n                    month=date.month,\n                    day=date.day,\n                    tzinfo=pytz.utc,\n                )\n\n            article[\"today\"] = datetime.date.today()\n            article[\"now\"] = datetime.datetime.now()\n            article[\"datetime\"] = date\n            if date is not None:\n                article[\"date\"] = date.date()\n    ```"}, {"title": "__init__.py", "status": "published", "slug": "markata/plugins/__init__", "path": "__init__.md", "today": "2022-02-05", "description": "Docs for __init__", "now": "2022-02-05 19:38:00.891439", "datetime": null, "long_description": "", "content": ""}, {"title": "rss.py", "status": "published", "slug": "markata/plugins/rss", "path": "rss.md", "today": "2022-02-05", "description": "Docs for rss", "now": "2022-02-05 19:38:00.891442", "datetime": null, "long_description": "", "content": "Default glob plugin\n\n\n---\n\n## render `function`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(markata: \"MarkataRss\") -> None:\n        fg = FeedGenerator()\n        url = markata.get_config(\"url\") or \"\"\n        title = markata.get_config(\"title\") or \"rss_feed\"\n        name = markata.get_config(\"author_name\") or \"\"\n        email = markata.get_config(\"author_email\") or \"\"\n        icon = markata.get_config(\"icon\") or \"\"\n        lang = markata.get_config(\"lang\") or \"\"\n        rss_description = markata.get_config(\"rss_description\") or \"rss_feed\"\n\n        fg.id(url + \"/rss.xml\")\n        fg.title(title)\n        fg.author(\n            {\n                \"name\": name,\n                \"email\": email,\n            }\n        )\n        fg.link(href=url, rel=\"alternate\")\n        fg.logo(icon)\n        fg.subtitle(rss_description)\n        fg.link(href=url + \"/rss.xml\", rel=\"self\")\n        fg.language(lang)\n\n        try:\n            all_posts = reversed(sorted(markata.articles, key=lambda x: x[\"date\"]))\n            posts = [post for post in all_posts if post[\"status\"] == \"published\"]\n        except BaseException:\n            posts = markata.articles\n\n        for article in posts:\n            fe = fg.add_entry()\n            fe.id(url + \"/\" + article[\"slug\"])\n            fe.title(article.metadata[\"title\"])\n            fe.published(article.metadata[\"datetime\"])\n            fe.description(article.metadata[\"description\"])\n            fe.summary(article.metadata[\"long_description\"])\n            fe.link(href=url + \"/\" + article[\"slug\"])\n            fe.content(article.article_html.translate(dict.fromkeys(range(32))))\n\n        markata.fg = fg\n        markata.rss = fg.rss_str(pretty=True)\n    ```\n\n\n---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"MarkataRss\") -> None:\n        output_dir = Path(markata.config[\"output_dir\"])\n        markata.fg.rss_file(str(output_dir / \"rss.xml\"))\n    ```\n\n\n---\n\n## MarkataRss `class`\n\nNone\n\n??? \"MarkataRss source\"\n    ``` python\n    class MarkataRss(Markata):\n            fg: \"FeedGenerator\"\n            rss: str\n    ```"}, {"title": "feeds.py", "status": "published", "slug": "markata/plugins/feeds", "path": "feeds.md", "today": "2022-02-05", "description": "Docs for feeds", "now": "2022-02-05 19:38:00.891445", "datetime": null, "long_description": "", "content": "---\n\n## MarkataFilterError `class`\n\nNone\n\n??? \"MarkataFilterError source\"\n    ``` python\n    class MarkataFilterError(RuntimeError):\n        ...\n    ```\n\n\n---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata):\n        config = markata.get_plugin_config(\"feeds\")\n        if config is None:\n            config[\"feeds\"] = dict()\n        if \"archive\" not in config.keys():\n            config[\"archive\"] = dict()\n            config[\"archive\"][\"filter\"] = \"True\"\n\n        description = markata.get_config(\"description\") or \"\"\n        url = markata.get_config(\"url\") or \"\"\n\n        template = Path(__file__).parent / \"default_post_template.html\"\n\n        for page, page_conf in config.items():\n            if page not in [\"cache_expire\", \"config_key\"]:\n                create_page(\n                    markata,\n                    page,\n                    description=description,\n                    url=url,\n                    template=template,\n                    **page_conf,\n                )\n\n        home = Path(markata.config[\"output_dir\"]) / \"index.html\"\n        archive = Path(markata.config[\"output_dir\"]) / \"archive\" / \"index.html\"\n        if not home.exists() and archive.exists():\n            shutil.copy(str(archive), str(home))\n    ```\n\n\n---\n\n## create_page `function`\n\nNone\n\n??? \"create_page source\"\n    ``` python\n    def create_page(\n        markata,\n        page,\n        tags=None,\n        status=\"published\",\n        template=None,\n        card_template=None,\n        filter=None,\n        description=None,\n        url=None,\n        title=\"feed\",\n    ):\n        def try_filter_date(x):\n            try:\n                return x[\"date\"]\n            except KeyError:\n                return -1\n\n        if filter is not None:\n            posts = reversed(sorted(markata.articles, key=try_filter_date))\n            try:\n                posts = [post for post in posts if eval(filter, post.to_dict(), {})]\n            except BaseException as e:\n                msg = textwrap.dedent(\n                    f\"\"\"\n                        While processing page='{page}' markata hit the following exception\n                        during filter='{filter}'\n                        {e}\n                        \"\"\"\n                )\n                raise MarkataFilterError(msg)\n\n        cards = [create_card(post, card_template) for post in posts]\n        cards.insert(0, \"<ul>\")\n        cards.append(\"</ul>\")\n\n        with open(template) as f:\n            template = Template(f.read())\n        output_file = Path(markata.config[\"output_dir\"]) / page / \"index.html\"\n        canonical_url = f\"{url}/{page}/\"\n        output_file.parent.mkdir(exist_ok=True, parents=True)\n\n        with open(output_file, \"w+\") as f:\n            f.write(\n                template.render(\n                    body=\"\".join(cards),\n                    url=url,\n                    description=description,\n                    title=title,\n                    canonical_url=canonical_url,\n                    today=datetime.datetime.today(),\n                )\n            )\n    ```\n\n\n---\n\n## create_card `function`\n\nNone\n\n??? \"create_card source\"\n    ``` python\n    def create_card(post, template=None):\n        if template is None:\n            if \"date\" in post.keys():\n                return textwrap.dedent(\n                    f\"\"\"\n                    <li class='post'>\n                    <a href=\"/{post['slug']}/\">\n                        {post['title']} {post['date'].year}-{post['date'].month}-{post['date'].day}\n                    </a>\n                    </li>\n                    \"\"\"\n                )\n            else:\n                return textwrap.dedent(\n                    f\"\"\"\n                    <li class='post'>\n                    <a href=\"/{post['slug']}/\">\n                        {post['title']}\n                    </a>\n                    </li>\n                    \"\"\"\n                )\n        try:\n            with open(template) as f:\n                template = Template(f.read())\n        except FileNotFoundError:\n            template = Template(template)\n        post[\"article_html\"] = post.article_html\n\n        return template.render(**post.to_dict())\n    ```\n\n\n---\n\n## try_filter_date `function`\n\nNone\n\n??? \"try_filter_date source\"\n    ``` python\n    def try_filter_date(x):\n            try:\n                return x[\"date\"]\n            except KeyError:\n                return -1\n    ```"}, {"title": "glob.py", "status": "published", "slug": "markata/plugins/glob", "path": "glob.md", "today": "2022-02-05", "description": "Docs for glob", "now": "2022-02-05 19:38:00.891448", "datetime": null, "long_description": "", "content": "Default glob plugin\n\n\n---\n\n## glob `function`\n\nNone\n\n??? \"glob source\"\n    ``` python\n    def glob(markata: \"Markata\") -> None:\n\n        markata.files = list(\n            flatten([Path().glob(str(pattern)) for pattern in markata.glob_patterns])\n        )\n        markata.content_directories = list(set([f.parent for f in markata.files]))\n\n        try:\n            ignore = markata.config[\"glob\"][\"use_gitignore\"] or True\n        except KeyError:\n            ignore = True\n\n        if ignore and (Path(\".gitignore\").exists() or Path(\".markataignore\").exists()):\n            import pathspec\n\n            lines = []\n\n            if Path(\".gitignore\").exists():\n                lines.extend(Path(\".gitignore\").read_text().splitlines())\n\n            if Path(\".markataignore\").exists():\n                lines.extend(Path(\".markataignore\").read_text().splitlines())\n\n            spec = pathspec.PathSpec.from_lines(\"gitwildmatch\", lines)\n\n            markata.files = [\n                file for file in markata.files if not spec.match_file(str(file))\n            ]\n    ```"}, {"title": "publish_dev_to_source.py", "status": "published", "slug": "markata/plugins/publish_dev_to_source", "path": "publish_dev_to_source.md", "today": "2022-02-05", "description": "Docs for publish_dev_to_source", "now": "2022-02-05 19:38:00.891450", "datetime": null, "long_description": "", "content": "---\n\n## should_join `function`\n\nNone\n\n??? \"should_join source\"\n    ``` python\n    def should_join(line):\n        if line == \"\":\n            return False\n        if line is None:\n            return False\n        if line[0].isalpha():\n            return True\n        if line[0].startswith(\"[\"):\n            return True\n        if line[0].startswith(\"!\"):\n            return True\n        return False\n    ```\n\n\n---\n\n## join_lines `function`\n\nNone\n\n??? \"join_lines source\"\n    ``` python\n    def join_lines(article):\n        lines = article.split(\"\\n\")\n        line_number = 0\n        while line_number + 1 < len(lines):\n            line = lines[line_number]\n            nextline = lines[line_number + 1]\n            if should_join(line) and should_join(nextline):\n                lines[line_number] = f\"{line} {nextline}\"\n                lines.pop(line_number + 1)\n            else:\n                line_number += 1\n\n        return \"\\n\".join(lines)\n    ```\n\n\n---\n\n## post_render `function`\n\nNone\n\n??? \"post_render source\"\n    ``` python\n    def post_render(markata: \"Markata\") -> None:\n        for post in markata.iter_articles(description=\"saving source documents\"):\n            from copy import copy, deepcopy\n\n            article = deepcopy(post)\n\n            before_keys = copy(list(article.keys()))\n            for key in before_keys:\n                if key not in DEV_TO_FRONTMATTER:\n                    del article[key]\n\n            article.content = join_lines(article.content)\n            article.content = join_lines(article.content)\n\n            if \"canonical_url\" not in article:\n                article[\"canonical_url\"] = f'{markata.config[\"url\"]}/{post[\"slug\"]}/'\n\n            if \"published\" not in article:\n                article[\"published\"] = True\n\n            if \"cover_image\" not in article:\n                article[\n                    \"cover_image\"\n                ] = f\"{markata.config['images_url']}/{post['slug']}.png\"\n            post.dev_to = article\n    ```\n\n\n---\n\n## save `function`\n\nNone\n\n??? \"save source\"\n    ``` python\n    def save(markata: \"Markata\") -> None:\n        output_dir = Path(str(markata.config[\"output_dir\"]))\n        output_dir.mkdir(parents=True, exist_ok=True)\n        for post in markata.iter_articles(description=\"saving source documents\"):\n\n            with open(output_dir / Path(post[\"slug\"]) / \"dev.md\", \"w+\") as f:\n                f.write(frontmatter.dumps(post.dev_to))\n    ```"}, {"title": "plugins.py", "status": "published", "slug": "markata/cli/plugins", "path": "plugins.md", "today": "2022-02-05", "description": "Docs for plugins", "now": "2022-02-05 19:38:00.891453", "datetime": null, "long_description": "", "content": "---\n\n## Plugins `class`\n\nNone\n\n??? \"Plugins source\"\n    ``` python\n    class Plugins:\n        def __init__(self, markata: \"Markata\"):\n            self.m = markata\n\n        def __rich__(self) -> Panel:\n            grid = Table.grid(expand=True)\n            grid.add_row(f\"[bright_blue]{len(self.m._pm.get_plugins())}[/] plugins\")\n            for plugin in self.m._pm.get_plugins():\n                grid.add_row(\n                    \"\".join(\n                        [\n                            \"[bright_black]\",\n                            \".\".join(plugin.__name__.split(\".\")[:-1]),\n                            \".[/]\",\n                            plugin.__name__.split(\".\")[-1],\n                        ]\n                    )\n                )\n            return Panel(grid, title=\"plugins\", border_style=\"gold1\")\n    ```\n\n\n---\n\n## __init__ `method`\n\nNone\n\n??? \"__init__ source\"\n    ``` python\n    def __init__(self, markata: \"Markata\"):\n            self.m = markata\n    ```\n\n\n---\n\n## __rich__ `method`\n\nNone\n\n??? \"__rich__ source\"\n    ``` python\n    def __rich__(self) -> Panel:\n            grid = Table.grid(expand=True)\n            grid.add_row(f\"[bright_blue]{len(self.m._pm.get_plugins())}[/] plugins\")\n            for plugin in self.m._pm.get_plugins():\n                grid.add_row(\n                    \"\".join(\n                        [\n                            \"[bright_black]\",\n                            \".\".join(plugin.__name__.split(\".\")[:-1]),\n                            \".[/]\",\n                            plugin.__name__.split(\".\")[-1],\n                        ]\n                    )\n                )\n            return Panel(grid, title=\"plugins\", border_style=\"gold1\")\n    ```"}, {"title": "runner.py", "status": "published", "slug": "markata/cli/runner", "path": "runner.md", "today": "2022-02-05", "description": "Docs for runner", "now": "2022-02-05 19:38:00.891456", "datetime": null, "long_description": "", "content": "---\n\n## Runner `class`\n\nDisplay Footer\n\n??? \"Runner source\"\n    ``` python\n    class Runner:\n        \"\"\"Display Footer\"\"\"\n\n        _status = \"waiting\"\n\n        _dirhash = \"\"\n        time = time.time()\n\n        def __init__(self, markata: \"Markata\") -> None:\n            self.m = markata\n\n        def run(self) -> None:\n            self.status = \"running\"\n            self.m.run()\n            self.time = time.time()\n            self.status = \"waiting\"\n\n        def __rich__(self) -> Panel:\n\n            if self._dirhash != self.m.content_dir_hash:\n                self.run()\n                self._dirhash = self.m.content_dir_hash\n\n            s = f\"runner is waiting {round(time.time() - self.time)}\"\n\n            return Panel(Text(s), border_style=\"green\", title=\"runner\")\n    ```\n\n\n---\n\n## __init__ `method`\n\nNone\n\n??? \"__init__ source\"\n    ``` python\n    def __init__(self, markata: \"Markata\") -> None:\n            self.m = markata\n    ```\n\n\n---\n\n## run `method`\n\nNone\n\n??? \"run source\"\n    ``` python\n    def run(self) -> None:\n            self.status = \"running\"\n            self.m.run()\n            self.time = time.time()\n            self.status = \"waiting\"\n    ```\n\n\n---\n\n## __rich__ `method`\n\nNone\n\n??? \"__rich__ source\"\n    ``` python\n    def __rich__(self) -> Panel:\n\n            if self._dirhash != self.m.content_dir_hash:\n                self.run()\n                self._dirhash = self.m.content_dir_hash\n\n            s = f\"runner is waiting {round(time.time() - self.time)}\"\n\n            return Panel(Text(s), border_style=\"green\", title=\"runner\")\n    ```"}, {"title": "server.py", "status": "published", "slug": "markata/cli/server", "path": "server.md", "today": "2022-02-05", "description": "Docs for server", "now": "2022-02-05 19:38:00.891459", "datetime": null, "long_description": "", "content": "---\n\n## find_port `function`\n\nFind a port not in ues starting at given port\n\n??? \"find_port source\"\n    ``` python\n    def find_port(port: int = 8000) -> int:\n        \"\"\"Find a port not in ues starting at given port\"\"\"\n        import socket\n\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            if s.connect_ex((\"localhost\", port)) == 0:\n                return find_port(port=port + 1)\n            else:\n                return port\n    ```\n\n\n---\n\n## Server `class`\n\nNone\n\n??? \"Server source\"\n    ``` python\n    class Server:\n        def __init__(\n            self,\n            auto_restart: bool = True,\n            directory: Union[str, \"Path\"] = None,\n            port: int = 8000,\n        ):\n            if directory is None:\n                from markata import Markata\n\n                m = Markata()\n                directory = Path(str(m.config[\"output_dir\"]))\n\n            self.auto_restart = auto_restart\n            self.directory = directory\n            self.port = find_port(port=port)\n            self.start_server()\n            atexit.register(self.kill)\n\n        def start_server(self) -> None:\n            import subprocess\n\n            self.cmd = [\n                \"python\",\n                \"-m\",\n                \"http.server\",\n                str(self.port),\n                \"--directory\",\n                self.directory,\n            ]\n\n            self.proc = subprocess.Popen(\n                self.cmd,\n                stderr=subprocess.PIPE,\n                stdout=subprocess.PIPE,\n            )\n            self.start_time = time.time()\n\n        @property\n        def uptime(self) -> int:\n            return round(time.time() - self.start_time)\n\n        def kill(self) -> None:\n            self.auto_restart = False\n            self.proc.kill()\n\n        def __rich__(self) -> Panel:\n            if not self.proc.poll():\n                return Panel(\n                    f\"[green]serving on port: [gold1]{self.port} [green]using pid: [gold1]{self.proc.pid} [green]uptime: [gold1]{self.uptime} [green]link: [gold1] http://localhost:{self.port}[/]\",\n                    border_style=\"blue\",\n                    title=\"server\",\n                )\n\n            else:\n\n                return Panel(f\"[red]server died\", title=\"server\", border_style=\"red\")\n    ```\n\n\n---\n\n## __init__ `method`\n\nNone\n\n??? \"__init__ source\"\n    ``` python\n    def __init__(\n            self,\n            auto_restart: bool = True,\n            directory: Union[str, \"Path\"] = None,\n            port: int = 8000,\n        ):\n            if directory is None:\n                from markata import Markata\n\n                m = Markata()\n                directory = Path(str(m.config[\"output_dir\"]))\n\n            self.auto_restart = auto_restart\n            self.directory = directory\n            self.port = find_port(port=port)\n            self.start_server()\n            atexit.register(self.kill)\n    ```\n\n\n---\n\n## start_server `method`\n\nNone\n\n??? \"start_server source\"\n    ``` python\n    def start_server(self) -> None:\n            import subprocess\n\n            self.cmd = [\n                \"python\",\n                \"-m\",\n                \"http.server\",\n                str(self.port),\n                \"--directory\",\n                self.directory,\n            ]\n\n            self.proc = subprocess.Popen(\n                self.cmd,\n                stderr=subprocess.PIPE,\n                stdout=subprocess.PIPE,\n            )\n            self.start_time = time.time()\n    ```\n\n\n---\n\n## uptime `method`\n\nNone\n\n??? \"uptime source\"\n    ``` python\n    def uptime(self) -> int:\n            return round(time.time() - self.start_time)\n    ```\n\n\n---\n\n## kill `method`\n\nNone\n\n??? \"kill source\"\n    ``` python\n    def kill(self) -> None:\n            self.auto_restart = False\n            self.proc.kill()\n    ```\n\n\n---\n\n## __rich__ `method`\n\nNone\n\n??? \"__rich__ source\"\n    ``` python\n    def __rich__(self) -> Panel:\n            if not self.proc.poll():\n                return Panel(\n                    f\"[green]serving on port: [gold1]{self.port} [green]using pid: [gold1]{self.proc.pid} [green]uptime: [gold1]{self.uptime} [green]link: [gold1] http://localhost:{self.port}[/]\",\n                    border_style=\"blue\",\n                    title=\"server\",\n                )\n\n            else:\n\n                return Panel(f\"[red]server died\", title=\"server\", border_style=\"red\")\n    ```"}, {"title": "__main__.py", "status": "published", "slug": "markata/cli/__main__", "path": "__main__.md", "today": "2022-02-05", "description": "Docs for __main__", "now": "2022-02-05 19:38:00.891461", "datetime": null, "long_description": "", "content": "---\n\n## MarkataWidget `class`\n\nNone\n\n??? \"MarkataWidget source\"\n    ``` python\n    class MarkataWidget(Widget):\n        def __init__(self, markata: Markata, widget: str = \"server\"):\n            super().__init__(widget)\n            self.m = markata\n            self.widget = widget\n            self.renderable = getattr(self.m, self.widget)\n\n        def render(self):\n            return self.renderable\n\n        async def update(self, renderable: RenderableType) -> None:\n            self.renderable = renderable\n            self.refresh()\n    ```\n\n\n---\n\n## MarkataApp `class`\n\nNone\n\n??? \"MarkataApp source\"\n    ``` python\n    class MarkataApp(App):\n        async def on_mount(self) -> None:\n            self.m = Markata()\n            self.server = MarkataWidget(self.m, \"server\")\n            self.runner = MarkataWidget(self.m, \"runner\")\n            self.plugins = MarkataWidget(self.m, \"plugins\")\n            self.summary = MarkataWidget(self.m, \"summary\")\n            await self.view.dock(self.plugins, edge=\"left\", size=30, name=\"plugins\")\n            await self.view.dock(self.summary, edge=\"right\", size=30, name=\"summary\")\n            await self.view.dock(self.server, self.runner, edge=\"top\")\n            self.set_interval(1, self.action_refresh)\n\n        async def on_load(self, event):\n            await self.bind(\"q\", \"my_quit\")\n            await self.bind(\"r\", \"refresh\")\n\n        async def action_my_quit(self) -> None:\n            await self.action_quit()\n\n        async def action_refresh(self) -> None:\n            self.refresh()\n            self.runner.refresh()\n            self.server.refresh()\n            self.plugins.refresh()\n            self.summary.refresh()\n    ```\n\n\n---\n\n## __init__ `method`\n\nNone\n\n??? \"__init__ source\"\n    ``` python\n    def __init__(self, markata: Markata, widget: str = \"server\"):\n            super().__init__(widget)\n            self.m = markata\n            self.widget = widget\n            self.renderable = getattr(self.m, self.widget)\n    ```\n\n\n---\n\n## render `method`\n\nNone\n\n??? \"render source\"\n    ``` python\n    def render(self):\n            return self.renderable\n    ```"}, {"title": "header.py", "status": "published", "slug": "markata/cli/header", "path": "header.md", "today": "2022-02-05", "description": "Docs for header", "now": "2022-02-05 19:38:00.891464", "datetime": null, "long_description": "", "content": "---\n\n## Header `class`\n\nDisplay header with clock.\n\n??? \"Header source\"\n    ``` python\n    class Header:\n        \"\"\"Display header with clock.\"\"\"\n\n        def __rich__(self) -> Panel:\n            grid = Table.grid(expand=True)\n            grid.add_column(justify=\"center\", ratio=1)\n            grid.add_column(justify=\"right\")\n            grid.add_row(\n                \"[magenta][b]Markata[/b][/] [bright_black]Live Server[/]\",\n                datetime.now().ctime(),\n            )\n            return Panel(grid, style=\"yellow\")\n    ```\n\n\n---\n\n## __rich__ `method`\n\nNone\n\n??? \"__rich__ source\"\n    ``` python\n    def __rich__(self) -> Panel:\n            grid = Table.grid(expand=True)\n            grid.add_column(justify=\"center\", ratio=1)\n            grid.add_column(justify=\"right\")\n            grid.add_row(\n                \"[magenta][b]Markata[/b][/] [bright_black]Live Server[/]\",\n                datetime.now().ctime(),\n            )\n            return Panel(grid, style=\"yellow\")\n    ```"}, {"title": "summary.py", "status": "published", "slug": "markata/cli/summary", "path": "summary.md", "today": "2022-02-05", "description": "Docs for summary", "now": "2022-02-05 19:38:00.891466", "datetime": null, "long_description": "", "content": "---\n\n## Summary `class`\n\nNone\n\n??? \"Summary source\"\n    ``` python\n    class Summary:\n        def __init__(self, m: \"Markata\", simple: bool = False) -> None:\n            self.m = m\n            self.simple = simple\n\n        def __rich__(self) -> Union[Panel, Table]:\n            grid = Table.grid(expand=True)\n            grid.add_row(f\"[bright_blue]{len(self.m.articles)}[/] articles\")\n            grid.add_row(\n                f\"[green]{len([a for a in self.m.articles if a['status'] =='published'])}[/] published\"\n            )\n            grid.add_row(\n                f\"[gold1]{len([a for a in self.m.articles if a['status'] =='draft'])}[/] drafts\"\n            )\n            grid.add_row(\"\")\n            grid.add_row(\"[bold gold1]TAGS[/]\")\n            from collections import Counter\n\n            from more_itertools import flatten\n\n            try:\n                for tag, count in Counter(\n                    list(flatten([a[\"tags\"] for a in self.m.articles]))\n                ).most_common():\n                    grid.add_row(f'{count} {\" \"*(3-len(str(count)))} {tag}')\n            except KeyError:\n                ...\n\n            try:\n                grid.add_row(\"[bold gold1]Series[/]\")\n                for series, count in Counter(\n                    [a[\"templateKey\"] for a in self.m.articles]\n                ).most_common():\n                    grid.add_row(f'{count} {\" \"*(3-len(str(count)))} {series}')\n            except KeyError:\n                ...\n            if self.simple:\n                return grid\n            else:\n                return Panel(grid, title=\"[gold1]summary[/]\", border_style=\"magenta\")\n    ```\n\n\n---\n\n## __init__ `method`\n\nNone\n\n??? \"__init__ source\"\n    ``` python\n    def __init__(self, m: \"Markata\", simple: bool = False) -> None:\n            self.m = m\n            self.simple = simple\n    ```\n\n\n---\n\n## __rich__ `method`\n\nNone\n\n??? \"__rich__ source\"\n    ``` python\n    def __rich__(self) -> Union[Panel, Table]:\n            grid = Table.grid(expand=True)\n            grid.add_row(f\"[bright_blue]{len(self.m.articles)}[/] articles\")\n            grid.add_row(\n                f\"[green]{len([a for a in self.m.articles if a['status'] =='published'])}[/] published\"\n            )\n            grid.add_row(\n                f\"[gold1]{len([a for a in self.m.articles if a['status'] =='draft'])}[/] drafts\"\n            )\n            grid.add_row(\"\")\n            grid.add_row(\"[bold gold1]TAGS[/]\")\n            from collections import Counter\n\n            from more_itertools import flatten\n\n            try:\n                for tag, count in Counter(\n                    list(flatten([a[\"tags\"] for a in self.m.articles]))\n                ).most_common():\n                    grid.add_row(f'{count} {\" \"*(3-len(str(count)))} {tag}')\n            except KeyError:\n                ...\n\n            try:\n                grid.add_row(\"[bold gold1]Series[/]\")\n                for series, count in Counter(\n                    [a[\"templateKey\"] for a in self.m.articles]\n                ).most_common():\n                    grid.add_row(f'{count} {\" \"*(3-len(str(count)))} {series}')\n            except KeyError:\n                ...\n            if self.simple:\n                return grid\n            else:\n                return Panel(grid, title=\"[gold1]summary[/]\", border_style=\"magenta\")\n    ```"}, {"title": "__init__.py", "status": "published", "slug": "markata/cli/__init__", "path": "__init__.md", "today": "2022-02-05", "description": "Docs for __init__", "now": "2022-02-05 19:38:00.891469", "datetime": null, "long_description": "", "content": ""}, {"title": "cli.py", "status": "published", "slug": "markata/cli/cli", "path": "cli.md", "today": "2022-02-05", "description": "Docs for cli", "now": "2022-02-05 19:38:00.891472", "datetime": null, "long_description": "", "content": "---\n\n## make_layout `function`\n\nDefine the layout.\n\n??? \"make_layout source\"\n    ``` python\n    def make_layout() -> Layout:\n        \"\"\"Define the layout.\"\"\"\n        layout = Layout(name=\"root\")\n\n        layout.split(\n            Layout(name=\"header\", size=3),\n            Layout(name=\"main\"),\n        )\n        layout[\"main\"].split_row(\n            Layout(name=\"side\", ratio=50),\n            Layout(name=\"mid\", ratio=30),\n            Layout(name=\"describe\", ratio=20),\n        )\n        layout[\"mid\"].split(\n            Layout(name=\"server\"),\n            Layout(name=\"runner\"),\n        )\n        layout[\"side\"].split(\n            Layout(name=\"plugins\"),\n        )\n        return layout\n    ```\n\n\n---\n\n## run_until_keyboard_interrupt `function`\n\nNone\n\n??? \"run_until_keyboard_interrupt source\"\n    ``` python\n    def run_until_keyboard_interrupt() -> None:\n        try:\n            while True:\n                time.sleep(0.2)\n        except KeyboardInterrupt:\n            pass\n    ```\n\n\n---\n\n## version_callback `function`\n\nNone\n\n??? \"version_callback source\"\n    ``` python\n    def version_callback(value: bool) -> None:\n        if value:\n            from markata import __version__\n\n            typer.echo(f\"Markata CLI Version: {__version__}\")\n            raise typer.Exit()\n    ```\n\n\n---\n\n## json_callback `function`\n\nNone\n\n??? \"json_callback source\"\n    ``` python\n    def json_callback(value: bool) -> None:\n        if value:\n            from markata import Markata\n\n            typer.echo(Markata().to_json())\n            raise typer.Exit()\n    ```\n\n\n---\n\n## main `function`\n\nNone\n\n??? \"main source\"\n    ``` python\n    def main(\n        version: bool = typer.Option(\n            None, \"--version\", callback=version_callback, is_eager=True\n        ),\n        to_json: bool = typer.Option(\n            None, \"--to-json\", callback=json_callback, is_eager=True\n        ),\n    ) -> None:\n        # Do other global stuff, handle other global options here\n        return\n    ```\n\n\n---\n\n## cli `function`\n\nNone\n\n??? \"cli source\"\n    ``` python\n    def cli() -> None:\n        from markata import Markata\n\n        m = Markata()\n        m._pm.hook.cli(markata=m, app=app)\n        app()\n    ```"}]}